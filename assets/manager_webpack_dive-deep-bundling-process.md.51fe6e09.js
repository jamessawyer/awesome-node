import{_ as s,c as n,o as a,V as o}from"./chunks/framework.19aa805b.js";const l="/awesome-node/assets/1.3ceb987e.png",p="/awesome-node/assets/2.a94f770e.webp",e="/awesome-node/assets/3.41940873.webp",c="/awesome-node/assets/4.764f4bf5.webp",t="/awesome-node/assets/5.d624237e.webp",r="/awesome-node/assets/6.2f535de6.webp",y="/awesome-node/assets/7.1d714553.webp",F="/awesome-node/assets/8.f3f89422.webp",D="/awesome-node/assets/9.5711a58e.webp",f=JSON.parse('{"title":"深入Webpack打包过程","description":"","frontmatter":{"title":"深入Webpack打包过程"},"headers":[],"relativePath":"manager/webpack/dive-deep-bundling-process.md","filePath":"manager/webpack/dive-deep-bundling-process.md","lastUpdated":1683625893000}'),i={name:"manager/webpack/dive-deep-bundling-process.md"},d=o('<p>原文链接🔗：</p><ul><li><a href="https://indepth.dev/posts/1482/an-in-depth-perspective-on-webpacks-bundling-process" target="_blank" rel="noreferrer">An in-depth perspective on Webpack&#39;s bundling process - @indpeth.dev</a></li></ul><p>Webpack 是一个非常强大和有趣的工具，可以被认为是当今许多Web开发人员用来构建应用程序的技术的基本组件。然而，许多人会认为使用它是一个相当大的挑战，主要是因为它的复杂性。</p><p>在本系列文章中，我想分享许多关于webpack内部工作的细节，希望它能让使用webpack看起来更平易近人。本文将作为未来发表的文章的基础，在这些文章中，我将更深入地探讨其他webpack的功能。<strong>你将了解延迟加载（<code>lazy loading</code>）的工作原理、摇树（<code>tree-shaking</code>）的工作原理、某些加载器（<code>loaders</code>）的工作原理等。</strong> 我在这个系列中的目标是让你在解决与webpack相关的问题时变得更加自在。本文的目的是为你提供有关<strong>整个过程</strong>的足够见解，以便你能够在任何时候进行干预，以便自己了解 webpack 的某些方面或调试问题。 因此，在最后一部分中，我们将看到如何通过测试和一些自定义示例来调试webpack的源代码。</p><p>我们将从一个图表开始，该图表描述了整个打包过程，它看起来很长。不过，一些细节被省略了，因为它们是未来文章的主题。然后，我们将展开讲解图中的一些步骤。随着我们的进行，我们还将解释模块（<code>modules</code>）、块（<code>chunks</code>）等概念。此外，为了简化理解，我将用图表和简化的代码片段替换源代码中的片段。但是，我将提供一些指向源代码的链接，也许它们会很有用。</p><p>作为规范，我们将 <code>NormalModule</code> 简单地称为模块（<code>modules</code>）。还有其他类型的模块，例如 <code>ExternalModule</code> （使用模块联邦时）和 <code>ConcatenatedModule</code> （使用 <code>require.context()</code> 时），它们是单独文章的主题。在本文中，我们将只关注 <code>NormalModule</code>。</p><p>如果你想在阅读本文时继续浏览源代码，你应该先查看调试webpack的源代码部分。</p><h2 id="使用图表可视化流程" tabindex="-1">使用图表可视化流程 <a class="header-anchor" href="#使用图表可视化流程" aria-label="Permalink to &quot;使用图表可视化流程&quot;">​</a></h2><p><img src="'+l+`" alt="Webpack bundle whole process"></p><p>原图在 <a href="https://excalidraw.com/#json=4517412917477376,mF3yLd-gYuRzCzWZ11fo7Q" target="_blank" rel="noreferrer">webpack Bundle process - Excalidraw</a></p><p>我强烈建议打开图表的Excalidraw链接，因为它将用作对即将进行的深入解释的支持，这些解释分为几部分，每个部分都描述了图表中的一个步骤或多个步骤。</p><p>让我们开始吧！</p><h2 id="entry对象" tabindex="-1">entry对象 <a class="header-anchor" href="#entry对象" aria-label="Permalink to &quot;entry对象&quot;">​</a></h2><p>值得一提的是，一切都以 <code>entry</code> 对象开头。如你所料，它支持许多配置，因此本主题值得单独撰写一篇文章。这就是为什么我们要考虑一个更简单的例子，其中 <code>entry</code> 对象只是键值对的集合：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-57pzp" id="tab-4LqVVtl" checked="checked"><label for="tab-4LqVVtl">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div></div><p>从概念上讲，webpack中的从概念上讲，webpack中的 <strong>模块(<code>module</code>)</strong> 与<em>文件</em>相关联。因此，在图中 <code>&#39;a.js&#39;</code> 将产生一个新模块， <code>&#39;b.js&#39;</code> 也是如此。</p><p>目前，<strong>保持模块是文件的升级版本这个粗略印象就足够了。模块一旦被创建和构建，除了原始源代码之外，还包含许多有意义的信息，例如：使用的加载器（<code>loaders</code>），依赖项（<code>dependencies</code>），导出（<code>exports</code>）（如果有的话），哈希（<code>hashes</code>）等等。</strong> 可以将 <code>entry</code> 对象中的每个项视为模块树（<code>a tree of modules</code>）中的根模块（<code>root module</code>）。模块树，因为根模块可能需要一些其他模块（即依赖项），这些模块可能需要其他模块等等，因此你可以看到如何在更高层次上构建这样的树。所有这些模块树都一起存储在 <code>ModuleGraph</code> ，我们将在下一节中介绍。</p><p>我们现在需要提到的下一件事是webpack是建立在很多<strong>插件</strong>之上的。尽管打包过程已经很好地建立起来，但是有很多方法可以添加自定义逻辑。📚webpack 中的可扩展性是通过 <code>hooks</code> 实现的。例如，你可以在构建 <code>ModuleGraph</code> 之后、为chunk生成新资源（<code>assets</code>）时、即将构建模块之前（运行加载程序并解析源代码）等添加自定义逻辑。我们还将在以后的文章中探讨它们，因为它们非常有趣，并且可以为许多与 webpack 定制相关的问题提供解决方案😎。大多数时候，钩子是按照它们的目的分组的，对于任何定义良好的目的，都有一个插件（<code>Plugin</code>）。 例如，有一个插件负责处理 <code>import()</code> 函数（负责解析注释和参数） - 它被称为 <a href="https://github.com/webpack/webpack/blob/main/lib/dependencies/ImportParserPlugin.js#L27" target="_blank" rel="noreferrer">ImportParserPlugin</a> ，它所做的就是在AST解析过程中遇到<code>import()</code>调用时添加一个钩子。。</p><p>📚有几个插件负责处理 <code>entry</code> 对象也就不足为奇了。有 <code>EntryOptionPlugin</code> ，它实际上接收 <code>entry</code> 对象并为对象中的<strong>每个项</strong>创建一个 <code>EntryPlugin</code> 。这部分很重要，也与本节开头提到的内容有关： <code>entry</code> 对象的每一项都会生成一个模块树（所有这些树都彼此分开）。基本上， <code>EntryPlugin</code> 开始创建模块树，每个模块树都会将信息添加到同一个地方， <code>ModuleGraph</code> 。非正式地说，我们会说是 <code>EntryPlugin</code> 开启了这个复杂的过程🎉。</p><p><img src="`+p+`" alt="EntryPlugin"></p><p>为了与初始图表相提并论，值得一提的是， <code>EntryPlugin</code> 也是创建 <code>EntryDependency</code> 的地方。</p><p>基于上图，让我们通过自己粗略地实现 <code>EntryOptionsPlugin</code> 来了解它的重要性：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CustomEntryOptionPlugin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 这是创建插件的一种标准方式🚀</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 要么是如下这种方式或者一个简单的函数</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 但我们为了演示大多数插件普遍的结构，采用如下方式</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">apply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compiler</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 回想一下，钩子（hooks）给我们提供了干预构建过程的可能性</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 1️⃣ 通过 \`entryOption\` 钩子，我们添加的逻辑基本上意味着打包过程的开始😎</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`entryObject\` 参数将保存来自配置文件中的 \`entry\` 对象</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 我们将用它来设置模块树🌲的创建</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">compiler</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">entryOption</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tap</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">CustomEntryOptionPlugin</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">entryObject</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// \`EntryOption\` 类将处理模块树🌲的创建</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">EntryOption</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">class</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">options</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">options</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">options</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 因为这仍旧是一个插件（Plugin）,我们遵守标准</span></span>
<span class="line"><span style="color:#F07178;">        apply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compiler</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// 2️⃣ \`start\` hook标志着bundling过程的开始</span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// 它将在 \`hooks.entryOption\` 调用之后被调用</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">compiler</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">start</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">EntryOption</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createModuleTree</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)) </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 3️⃣ 基于这个插件的配置，创建一个新的模块树</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// \`options\` 包含entry和文件的名字（也将是该chunk的名字）</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// \`EntryDependency\` 封装了这些配置项，同时提供了创建模块的方式</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">//（因为它将映射到 \`NormalModuleFactory\`, NormalModuleFactory将生成 \`NormalModule\`）</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 在调用 \`createModuleTree\` 之后，该文件的源代码将被找到</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 然后一个模块实例将被创建，然后Webpack将得到它的AST，该AST将进一步用作在bundling过程中</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">createModuleTree</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">EntryDependency</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">options</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 对于 \`entryObject\` 中的每一项，我们都准备创建一个模块树。</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 🎉 记住，每一个模块树都是彼此相互独立的</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// \`entryObject\` 可能类似于 \`{ a: &#39;./a.js&#39; }\`</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">entryObject</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">entryObject</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 这相当于在说：</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// \`ok webpack, 当bundling过程开始时，请准备好给这个entry创建一个模块树\`</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">EntryOption</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileName</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">compiler</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="dependency" tabindex="-1">Dependency <a class="header-anchor" href="#dependency" aria-label="Permalink to &quot;Dependency&quot;">​</a></h3><p>在本节的最后一部分中，我们将稍微展开讲一下 <code>Dependency</code> 是什么，因为我们将在本文中进一步使用它，并将在其他文章中提及它。你现在可能想知道 <code>EntryDependency</code> 是什么以及为什么需要它🤔。📚从我的角度来看，当涉及到创建新模块时，一切都归结于智能抽象(<code>smart abstraction</code>)。简单地说，依赖(<code>dependency</code>)只是实际模块(<code>module</code>)实例的前提条件。例如，即使是 <code>entry</code> 对象的项也是webpack眼中的依赖，它们指示要创建的 <code>module</code> 实例的最低要求：它的<strong>路径</strong>（例如 <code>./a.js</code> 、 <code>./b.js</code> ）。</p><ul><li>如果没有依赖项，模块的创建就无法启动，因为依赖项包含模块的 <strong>请求（<code>request</code>）</strong> 等重要信息，比如：可以找到模块源代码的文件的路径（例如 <code>&#39;./a.js&#39;</code> ）</li><li>依赖项还指示如何构造该模块，它使用模块工厂(<code>module factory</code>)执行此操作。<strong>模块工厂</strong>知道如何从原始状态（例如，源代码是一个简单的字符串）开始，然后到达具体的实体，然后被webpack利用。</li><li><a href="https://github.com/webpack/webpack/blob/main/lib/dependencies/EntryDependency.js#L11" target="_blank" rel="noreferrer">EntryDependency</a> 实际上是 <a href="https://github.com/webpack/webpack/blob/main/lib/dependencies/ModuleDependency.js#L19" target="_blank" rel="noreferrer">ModuleDependency</a> 的一种子类型，这意味着它肯定会保存模块的请求（<code>request</code>），并且它指向的模块工厂是 <code>NormalModuleFactory</code>。然后， <code>NormalModuleFactory</code> 确切地知道该怎么做才能从路径创建对 webpack 有意义的东西。</li></ul><p>另一种思考方式是，模块最初只是一个简单的路径（在 <code>entry</code> 对象或 <code>import</code> 语句的一部分中），然后它变成了依赖项，最后变成了一个模块。</p><p>以下是可视化的一种方法：<a href="https://excalidraw.com/#json=4907940771266560,zqDQZYTbwHupJqyFprykWA" target="_blank" rel="noreferrer">EntryDependency to NormalModule 原图</a></p><p><img src="`+e+`" alt="EntryDependency -&gt; NormalModule"></p><p>📚因此，在创建模块树的根模块（<code>root module</code>）时，在开头使用 <code>EntryDependency</code> 。</p><p>对于其余模块，还有其他类型的依赖项。例如，如果你使用 <code>import</code> 语句，例如 <code>import defaultFn from &#39;./a.js&#39;</code> ，那么将有一个 <code>HarmonyImportSideEffectDependency</code> 保存模块的请求（在本例中为 <code>&#39;./a.js&#39;</code> ），并且还映射到 <code>NormalModuleFactory</code> 。因此，文件 <code>&#39;a.js&#39;</code> 将有一个新模块，希望现在你可以看到<strong>依赖项</strong>所扮演的重要作用。它们本质上指导 webpack 如何创建 <code>modules</code> 。我们将在本文后面介绍有关依赖项的更多信息。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>对于 <code>entry</code> 对象中的每个项，都将有一个<code>EntryPlugin</code>实例，在其中创建一个<code>EntryDependency</code>。这个 <code>EntryDependency</code> 保存模块的请求(<code>request</code>)（即<strong>文件的路径</strong>），并且还提供了一种通过映射到模块工厂（即 <code>NormalModuleFactory</code> ）来使该请求有用的方法。模块工厂知道如何仅从文件路径创建对 webpack 有用的实体。</p><p>同样，<strong>依赖项</strong>对于创建模块至关重要，因为它包含重要信息，例如模块的请求以及如何处理该请求。有几种类型的依赖项，并非所有依赖项都对创建新模块有用。从每个 <code>EntryPlugin</code> 实例中，在新创建的 <code>EntryDependency</code> 的帮助下，将创建一个模块树。 <strong>模块树构建在模块及其依赖项之上，这些依赖项以及模块也可以具有依赖项。</strong></p><p>现在，让我们通过了解有关 <code>ModuleGraph</code> 的更多信息来继续我们的学习之旅。</p><h2 id="理解modulegraph" tabindex="-1">理解ModuleGraph <a class="header-anchor" href="#理解modulegraph" aria-label="Permalink to &quot;理解ModuleGraph&quot;">​</a></h2><p>📚 <code>ModuleGraph</code> 是一种跟踪已构建模块（<code>built modules</code>）的方法。它严重依赖依赖关系，因为它们提供了连接 2 个不同模块的方法。例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// a.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> defaultBFn </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// b.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello from B!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这里我们有2个文件，所以存在2个模块。文件 <code>a</code> 需要文件 <code>b</code> 中的某些内容，因此在 <code>a</code> 中有一个由 <code>import</code> 语句建立的依赖项。</p><p>就 <code>ModuleGraph</code> 而言，依赖项定义了连接 2 个模块的方法。甚至上一节中的 <code>EntryDependency</code> 也连接了2个模块：图（<code>graph</code>）的根模块（我们将其称为 <code>null 模块</code>）和与入口文件关联的模块。上面的代码片段可以可视化如下：</p><p><img src="`+c+`" alt="A depends on B"></p><p>区分简单模块（即 <code>NormalModule</code> 实例）和属于 <code>ModuleGraph</code> 的模块之间的区别很重要。<code>ModuleGraph</code> 的节点称为 <a href="https://github.com/webpack/webpack/blob/main/lib/ModuleGraph.js#L122" target="_blank" rel="noreferrer">ModuleGraphModule</a>，它只是一个修饰过的 <code>NormalModule</code> 实例。<code>ModuleGraph</code> 通过 <a href="https://github.com/webpack/webpack/blob/main/lib/ModuleGraph.js#L120" target="_blank" rel="noreferrer">map</a> 这种数据结构（它的签名为 <code>Map&lt;Module, ModuleGraphModule&gt;</code>）追踪装饰后的模块。这些方面是必要的，因为如果只有 <code>NormalModule</code> 实例，那么你对它们能做的事情就太少了，它们不知道如何相互通信。<code>ModuleGraph</code> 通过借助上述映射将它们互连来赋予这些裸模块（bare modules）的含义，该映射为每个 <code>NormalModule</code> 分配了一个 <code>ModuleGraphModule</code> 。这句话的含义在 <code>Building the ModuleGraph</code> 章节的末尾显得更有意义，我们将在其中使用 <code>ModuleGraph</code> 及其内部映射来遍历图。我们将属于 <code>ModuleGraph</code> 的模块简单地称为 <code>module</code> ，因为差异仅由一些其他属性组成。</p><p>对于属于ModuleGraph的节点，有几件事情是明确定义的：入站连接(<code>incoming connections</code>)和出站连接(<code>outgoing connections</code>)。连接是 <code>ModuleGraph</code> 的另一个小实体，它包含有意义的信息，例如：<em>源模块，目标模块和连接前面提到的2个模块的依赖项</em>。具体来说，基于上图，创建了一个新连接：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 基于上图和上面的代码片段</span></span>
<span class="line"><span style="color:#FFCB6B;">Connection</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">originModule</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">A</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">destinationModule</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">B</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">dependency</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ImportDependency</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>并且上面的连接将被添加到 <code>A.outgoingConnections</code> 集合和 <code>B.incomingConnections</code> 集合中。</p><p>这些是 <code>ModuleGraph</code> 的基本概念。如上一节所述，从入口（<code>entryObject</code>）创建的所有模块树都将向同一个位置 <code>ModuleGraph</code> 输出有意义的信息。这是因为所有这些模块树最终都将与<strong>null模块</strong>（ <code>ModuleGraph</code> 的根模块）连接。与<strong>null模块</strong>的连接是通过 <code>EntryDependency</code> 和从入口文件创建的模块建立的。以下是我对 <code>ModuleGraph</code> 的看法：<a href="https://excalidraw.com/#json=6723625398829056,kgoBBvUYMyhqGk6dOvY2Sg" target="_blank" rel="noreferrer">ModuleGraph原图</a></p><p><img src="`+t+`" alt="ModuleGraph"></p><p>如您所见，null 模块与从 <code>entry</code> 对象中的项生成的每个模块树的根模块有连接。图形中的每个边代表 2 个模块之间的连接，每个连接包含有关源节点、目标节点和依赖项的信息（这非正式地回答了<em><strong>为什么这两个模块连接的问题？</strong></em>)</p><p>现在我们对 <code>ModuleGraph</code> 有了更熟悉一点，让我们看看它是如何构建的。</p><h2 id="构建modulegraph" tabindex="-1">构建ModuleGraph <a class="header-anchor" href="#构建modulegraph" aria-label="Permalink to &quot;构建ModuleGraph&quot;">​</a></h2><p>正如我们在上一节中看到的， <code>ModuleGraph</code> 从一个<code>null模块</code>开始，该模块的直接后代是从 <code>entry</code> 对象的项构建的模块树的根模块。出于这个原因，为了理解 <code>ModuleGraph</code> 是如何构建的，我们将检查单个模块树的构建过程。</p><h3 id="要创建的第一个模块" tabindex="-1">要创建的第一个模块 <a class="header-anchor" href="#要创建的第一个模块" aria-label="Permalink to &quot;要创建的第一个模块&quot;">​</a></h3><p>我们将从一个非常简单的 <code>entry</code> 对象开始：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-Y8z7L" id="tab-DiDU_vN" checked="checked"><label for="tab-DiDU_vN">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div></div><p>根据 <a href="#entry对象">第一节</a> 中所说的内容，在某些时候，我们最终会得到一个 <code>EntryDependency</code> ，其请求是 <code>&#39;./a.js&#39;</code>。此 <code>EntryDependency</code> 提供了一种从该请求创建有意义的内容的方法，因为它映射到模块工厂，即 <code>NormalModuleFactory</code> 。这是我们在第一部分中断的地方。</p><p>该过程的下一步是 <code>NormalModuleFactory</code> 发挥作用的时候了。如果 <code>NormalModuleFactory</code> 成功完成其任务，将创建一个 <code>NormalModule</code> 。</p><p><strong>为了确保没有不确定性， <code>NormalModule</code> 只是文件源代码的反序列化版本，只不过是一个原始字符串。</strong> 原始字符串不会带来太多价值，因此 webpack 不能用它做太多事情。 <code>NormalModule</code> 还将源代码存储为字符串，但同时，它还将包含其他有用的信息和功能，例如：应用于它的加载器、构建模块的逻辑、生成运行时代码的逻辑、其哈希值等等😎。<strong>换句话说，从 webpack 的角度来看， <code>NormalModule</code> 是简单原始文件的有用版本。</strong></p><p>为了使 <code>NormalModuleFactory</code> 输出 <code>NormalModule</code> ，它必须经过一些步骤。创建模块后，还需要执行一些操作，例如构建模块并处理其依赖项（如果有依赖项的话）。</p><p>这是我们一直关注的图表，现在专注于构建 <code>ModuleGraph</code> 部分：</p><p><img src="`+r+'" alt="构建ModuleGraph"></p><p><code>NormalModuleFactory</code> 通过调用其 <a href="https://github.com/webpack/webpack/blob/main/lib/NormalModuleFactory.js#L759" target="_blank" rel="noreferrer">create</a> 方法开始它的魔力。然后，解析过程(<code>resolving process</code>)开始。这个方法是请求（<code>request</code>）（文件的路径）被解析，以及确认作用于该类型文件的加载器（<code>loaders</code>）的位置。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>请注意，这里将仅确定loaders的文件路径，此步骤中尚未调用loaders。</p></div><h3 id="模块的构建过程" tabindex="-1">模块的构建过程 <a class="header-anchor" href="#模块的构建过程" aria-label="Permalink to &quot;模块的构建过程&quot;">​</a></h3><p>解析所有必要的文件路径后， <code>NormalModule</code> 被创建。但是，此时，该模块不是很有价值😅。许多相关信息将在模块<strong>构建完成后</strong>提供。 <code>NormalModule</code> 的构建过程包括其他几个步骤：</p><ol><li>首先，加载器将对原始源代码进行调用;如果有多个加载器，则一个加载器的输出可能是另一个加载器的输入（配置文件中提供加载器的顺序很重要）;</li><li>其次，运行所有加载器后的结果字符串将使用 <a href="https://github.com/acornjs/acorn" target="_blank" rel="noreferrer">acorn</a>（JavaScript 解析器）进行解析，从而生成给定文件的 AST;</li><li>最后，将分析AST；分析是必要的，因为在此阶段将<strong>确定当前模块的依赖关系</strong>（例如其他模块），Webpack可以检测其<strong>魔术函数</strong>（例如 <code>require.context</code> ， <code>module.hot</code> ）等；AST 分析发生在 <a href="https://github.com/webpack/webpack/blob/main/lib/javascript/JavascriptParser.js#L195" target="_blank" rel="noreferrer">JavascriptParser</a> 中，如果你点击链接，你应该会看到那里处理了很多情形；流程的这一部分是最重要的部分之一，因为bundling过程中接下来的很多事情都取决于这一部分;🚀</li></ol><h3 id="通过生成的ast发现依赖" tabindex="-1">通过生成的AST发现依赖 <a class="header-anchor" href="#通过生成的ast发现依赖" aria-label="Permalink to &quot;通过生成的AST发现依赖&quot;">​</a></h3><p>在不赘述太多细节的情况下，思考发现过程（<code>discovery process</code>）的一种方法是：</p><p><img src="'+y+'" alt="模块的依赖收集"></p><p>其中 <code>moduleInstance</code> 是指从 <code>index.js</code> 文件创建的 <code>NormalModule</code> 。红色的 <code>dep</code> 表示从第一个 <code>import</code> 语句创建的依赖项，蓝色的 <code>dep</code> 表示第二个 <code>import</code> 语句。这只是一种简化的思考方式。实际上，如前所述，依赖项是在<strong>获取AST之后</strong>添加的。</p><p>现在AST已经被检查过了，是时候继续构建我们在本节开头谈到的模块树的过程了。下一步是<strong>处理</strong>在上一步中找到的<strong>依赖项</strong>。 <code>index</code> 模块有 2 个依赖项，它们也是模块，即 <code>math.js</code> 和 <code>utils.js</code>。但是在依赖项成为实际模块之前，我们只有 <code>index</code> 模块，其 <code>module.dependencies</code> 有 2 个值，其中包含模块请求（文件的路径）、导入说明符（例如 <code>sum</code> 、 <code>greet</code> ）等信息。 为了将它们转换为模块，我们需要使用这些依赖项映射到的 <code>ModuleFactory</code> 并<strong>重复</strong>上述相同的步骤（重复由本节开头所示图中的虚线箭头表示）😎。</p><p><strong>📚处理当前模块的依赖项后，这些依赖项可能也具有依赖项，此过程将继续，直到不再有依赖项。这就是构建模块树的方式，当然要确保正确设置父模块和子模块之间的连接。</strong></p><p>根据我们目前掌握的知识，自己实际尝试 <code>ModuleGraph</code> 将是一个很好的练习。为此，让我们看看一种实现自定义插件的方法，该插件将允许我们遍历 <code>ModuleGraph</code> 。下图描述了模块如何相互依赖：</p><p><img src="'+F+`" alt="ModuleGraph"></p><p>为了确保图表中的所有内容都是可理解的， <code>a.js</code> 文件导入 <code>b.js</code> 文件，该文件同时导入 <code>b1.js</code> 和 <code>c.js</code> ，然后 <code>c.js</code> 导入 <code>c1.j</code> 和 <code>d.js</code> ，最后， <code>d.js</code> 导入 <code>d1.js</code> 。最后， <code>ROOT</code> 指的是空模块，它是 <code>ModuleGraph</code> 的根。 <code>entry</code> 选项仅包含一个值 <code>a.js</code> ：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-Kk-Zq" id="tab-puQHUTi" checked="checked"><label for="tab-puQHUTi">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">(__dirname</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./src/a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div></div><p>现在让我们看看我们的自定义插件会是什么样子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 通过 \`tap\` 方法给已有的webpack hooks添加逻辑</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 其函数签名为： \`tap(string, callback)\`</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//  - \`string\` 仅用作debug目的，用于显示自定义逻辑是在源码的什么位置添加的</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//  - \`callback\`的参数取决于我们添加自定义功能的钩子</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UnderstandingModuleGraphPlugin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">apply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compiler</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">className</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 📚 关于 \`compilation\` 对象：它是保存大部分打包过程状态的地方。</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 它包含了如下一些信息</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - module graph</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - chunk graph</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - 已创建的chunks</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - 已创建的modules</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - 已生成的assets</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//  - 等等</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">compiler</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">compilation</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">className</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compilation</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// \`finishModules\` 会在所有模块（包括其依赖，以及依赖的依赖，依此类推）构建完成之后调用</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">compilation</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">finishModules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">className</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">modules</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// \`modules\` 是包含所有已构建模块的集合</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 它们都是简单的 \`NormalModule\` 实例</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 再次说明一下，而 \`NormalModule\` 则是由 \`NormalModuleFactory\` 创建的</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// console.log(modules)</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 取出所有的 \`module map\` (Map&lt;Module, ModuleGraphModule&gt;)</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 它包含我们遍历graph所需的所有信息</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          moduleGraph</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> _moduleMap</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">moduleMap</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">compilation</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 通过DFS（深度优先）的方式遍历module graph</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dfs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// 回想一下，\`ModuleGraph\` 的根模块是 \`null module\`</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">root</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F07178;">          </span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">visited</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">          </span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">traverse</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">crtNode</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">visited</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">crtNode</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">              </span><span style="color:#89DDFF;font-style:italic;">return</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">visited</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">crtNode</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">            </span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">              </span><span style="color:#A6ACCD;">crtNode</span><span style="color:#89DDFF;">?.</span><span style="color:#A6ACCD;">resource</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">basename</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">crtNode</span><span style="color:#89DDFF;">?.</span><span style="color:#A6ACCD;">resource</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ROOT</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">            )</span></span>
<span class="line"><span style="color:#F07178;">            </span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 获取关联的 \`ModuleGraphModule\`, 它在 \`NormalModule\` 之上包含一些</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 可用于进一步遍历graph的属性</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">correspondingGraphModule</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">moduleMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">crtNode</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">            </span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// \`Connection\` 的 \`originModule\` 属性是箭头的开始位置</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 而 \`Connection\` 的 \`module\` 属性则是箭头的结束位置</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 因此 \`Connection\` 的 \`module\` 是一个子节点</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// https://github.com/webpack/webpack/blob/main/lib/ModuleGraphConnection.js#L53 可以了解更多graph的connetion</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// \`correspondingGraphModule.outgoingConnections\` 要么是一个Set，要么是undefined（node没有子节点的情形）</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 我们使用 \`new Set\` 是因为一个模块可以通过多个连接引用同一模块</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 🌰 比如：\`import foo from &#39;file.js&#39;\` 将产生2个connections:(这是一个你不应该担心的实现细节😊)</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">//    - 一个简单的import</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">//    - 一个 \`foo\` 默认指示符</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Set</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">              </span><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#A6ACCD;">correspondingGraphModule</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">outgoingConnections</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> []</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#A6ACCD;font-style:italic;">c</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">module</span></span>
<span class="line"><span style="color:#F07178;">              )</span></span>
<span class="line"><span style="color:#F07178;">            )</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">              </span><span style="color:#82AAFF;">traverse</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">            </span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">          </span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// 开始遍历</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#82AAFF;">traverse</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">root</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">dfs</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这个实例可以在 <a href="https://stackblitz.com/edit/node-rxfljv?file=webpack.config.js" target="_blank" rel="noreferrer">StackBlitz</a> 查看， 确保运行 <code>npm run build</code> 以查看插件的运行情况。根据模块层次结构，运行 <code>build</code> 命令后，这是我们应该得到的输出：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">a.js</span></span>
<span class="line"><span style="color:#FFCB6B;">b.js</span></span>
<span class="line"><span style="color:#FFCB6B;">b1.js</span></span>
<span class="line"><span style="color:#FFCB6B;">c.js</span></span>
<span class="line"><span style="color:#FFCB6B;">c1.js</span></span>
<span class="line"><span style="color:#FFCB6B;">d.js</span></span>
<span class="line"><span style="color:#FFCB6B;">d1.js</span></span></code></pre></div><p>现在 <code>ModuleGraph</code> 已经构建完毕，希望你已经掌握了它，是时候了解接下来会发生什么了。根据主图，下一步将是<strong>创建块（<code>chunks</code>）</strong>，所以让我们进入它。但在此之前，值得理清一些重要的概念，例如 <code>Chunk</code> ， <code>ChunkGroup</code> 和 <code>EntryPoint</code> 。</p><h2 id="理清chunk-chunkgroup-entrypoint" tabindex="-1">理清Chunk,ChunkGroup,EntryPoint <a class="header-anchor" href="#理清chunk-chunkgroup-entrypoint" aria-label="Permalink to &quot;理清Chunk,ChunkGroup,EntryPoint&quot;">​</a></h2><p>现在我们已经对模块有了更多的熟悉，我们将在此基础上解释本节标题中提到的概念。</p><p>📚为了再次快速解释模块是什么，<strong>知道模块是文件的升级版本就足够了。模块一旦创建和构建，除了原始源代码之外，还包含许多有意义的信息，例如：使用的加载器，依赖项，导出（如果有），哈希等等。</strong></p><p>1️⃣ <strong><code>Chunk</code> 封装一个或多个模块。</strong> 乍一看，人们可能会认为入口文件的数量（入口文件 = <code>entry</code> 对象的items）与生成的块的数量成正比。这语句部分正确，因为 <code>entry</code> 对象可能只有一个item，并且生成的块数可能大于1。确实，对于每个 <code>entry</code> 项，dist 目录中都会有一个相应的块，但可以隐式创建其他块，例如在使用 <code>import()</code> 函数时。但无论如何创建，每个块都将在 dist 目录中有一个相应的文件。我们将在构建 <code>ChunkGraph</code> 部分中对此进行扩展，我们将阐明哪些模块属于 <code>chunk</code> ，哪些不属于。</p><p>2️⃣ <strong><code>ChunkGroup</code> 包含一个或多个区块。</strong> <code>ChunkGroup</code> 可以是另一个 <code>ChunkGroup</code> 的父项或子项。例如，当使用动态导入时，对于使用的每个 <code>import()</code> 函数，将创建一个 <code>ChunkGroup</code> ，其父级将是现有的 <code>ChunkGroup</code> ，该函数包含使用 <code>import()</code> 函数的文件（即模块）。可以在构建 <code>ChunkGraph</code> 部分中看到这一事实的可视化效果。</p><p>3️⃣ <strong><code>EntryPoint</code> 是为 <code>entry</code> 对象中的每个项创建的 <code>ChunkGroup</code> 类型。</strong> 一个块属于 <code>EntryPoint</code> 的事实对渲染过程有影响，我们将在未来的文章中更清楚地阐述。</p><p>鉴于我们更熟悉这些概念，让我们继续了解 <code>ChunkGraph</code> 。</p><h3 id="构建chunkgraph" tabindex="-1">构建ChunkGraph <a class="header-anchor" href="#构建chunkgraph" aria-label="Permalink to &quot;构建ChunkGraph&quot;">​</a></h3><p>回想一下，到目前为止，我们所拥有的只是一个 <code>ModuleGraph</code> ，我们在上一节中谈到了这一点。但是， <code>ModuleGraph</code> 只是Bundling过程的必要部分。必须利用它才能实现代码拆分等功能。</p><p>在Bundling过程的此时，对于 <code>entry</code> 对象中的每一项，将有一个 <code>EntryPoint</code> 。由于它是 <code>ChunkGroup</code> 的一种类型，因此它将至少包含一个块（<code>chunk</code>）。因此，如果 <code>entry</code> 对象有 3 个items，则将有 3 个 <code>EntryPoint</code> 实例，每个实例都有一个块，也称为<strong>入口点块</strong>，其名称是 <code>entry</code> 项键的值。与入口文件关联的模块称为<strong>入口模块</strong>，每个模块都属于其入口点块。它们很重要，因为它们是 <code>ChunkGraph</code> 构建过程的起点😎。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>请注意，一个块可以有多个<strong>入口模块</strong></p></div><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-xYJLB" id="tab-lDLvNaR" checked="checked"><label for="tab-lDLvNaR">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div></div><p>在上面的示例中，将有一个名为 <code>foo</code> 的块（item的键）将具有 2 个入口模块：一个与 <code>a.js</code> 文件关联，另一个与 <code>b.js</code> 文件关联。当然，该块将属于基于 <code>entry</code> 项创建的 <code>EntryPoint</code> 实例。</p><p>🌰在详细介绍之前，让我们举一个示例，在此基础上我们将讨论构建过程：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> js  </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#A6ACCD;">(__dirname</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">src/a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#A6ACCD;">(__dirname</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">src/a1.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#A6ACCD;">(__dirname</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">src/c.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>此示例将包含前面提到的内容： <code>ChunkGroups</code> 的父子关系（以及动态导入），<code>Chunks</code> 和 <code>EntryPoints</code>。</p><ul><li>可在 <a href="https://stackblitz.com/edit/node-z6d8js?file=readme.md" target="_blank" rel="noreferrer">Stackblitz</a> 查看该示例</li></ul><p><code>ChunkGraph</code> 以递归方式构建：</p><ol><li>它首先将所有入口模块（<code>entry modules</code>）添加到队列中</li><li>然后，当处理入口模块时，这意味着将检查其依赖项（也是模块），并且每个依赖项也将添加到队列中。</li><li>这将继续重复，直到队列变为空。该过程的这一部分是访问模块的位置。</li></ol><p>但是，这只是第一部分。回想一下， <code>ChunkGroup</code> 可以是其他 <code>ChunkGroup</code> 的父/子。这些连接在第二部分中解决。例如，如前所述，动态导入（即 <code>import()</code> 函数）将产生一个新的子 <code>ChunkGroup</code> 。用webpack的行话， <code>import()</code> 表达式定义了一个<strong>异步的</strong>依赖块。从我的角度来看，它被称为块（<code>block</code>），因为首先想到的是包含其他对象的东西。在 <code>import(&#39;./foo.js&#39;.then(module =&gt; ...)</code> 的情况下，很明显我们的目的是异步加载一些东西，很明显，为了使用 <code>module</code> 变量， <code>foo</code> 的所有依赖项（即模块）（包括 <code>foo</code> 本身）必须在实际模块可用之前被解析。我们将在以后的文章中彻底讨论 <code>import()</code> 函数的工作原理及其特殊性（例如魔术注释和其他选项）。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果这激发了你的好奇心，<a href="https://github.com/webpack/webpack/blob/main/lib/dependencies/ImportParserPlugin.js#L27" target="_blank" rel="noreferrer">这里</a>是在 AST 分析期间创建block的地方。</p></div><p><em>总结</em> <code>ChunkGraph</code> <em>构建过程的源代码可以在<a href="https://github.com/webpack/webpack/blob/main/lib/buildChunkGraph.js#L1277-L1299" target="_blank" rel="noreferrer">这里</a>找到。</em></p><p>现在，让我们看看从上面的配置创建的 <code>ChunkGraph</code> 的图：<a href="https://excalidraw.com/#json=6255037734977536,S8OwG9rWcdgphRWDBoiZwg" target="_blank" rel="noreferrer">ChunkGraph原图 - @excalidraw</a></p><p><img src="`+D+`" alt="ChunkGraph"></p><p>该图说明了 <code>ChunkGraph</code> 的一个非常简化的版本，但它应该足以突出显示生成的块和 <code>ChunkGroup</code> 之间的关系。我们可以看到 4 个块，因此将有 4 个输出文件。 <code>foo</code> 块将有 4 个模块，其中 2 个是<strong>入口模块(<code>entry modules</code>)</strong>。 <code>bar</code> 块将只有一个入口模块，另一个可以被视为普通模块。我们还可以注意到，每个 <code>import()</code> 表达式都会产生一个新的 <code>ChunkGroup</code> （其父项是 <code>bar EntryPoint</code> ），它涉及一个新块。</p><p>生成的文件的内容是根据 <code>ChunkGraph</code> 确定的，所以这就是为什么它对整个Bundling过程非常重要的原因。我们将在下一节中简要讨论<code>chunk assets</code>（即生成的文件）。</p><p>在探索我们使用 <code>ChunkGraph</code> 的实际示例之前，重要的是要提到它的一些特殊性。😃与 <code>ModuleGraph</code> 类似，属于 <code>ChunkGraph</code> 的节点称为 <a href="https://github.com/webpack/webpack/blob/main/lib/ChunkGraph.js#L204" target="_blank" rel="noreferrer">ChunkGraphChunk</a> （读作属于 <code>ChunkGraph</code> 的chunk），它只是一个<strong>装饰块</strong>，这意味着它是一些额外的属性，例如作为块一部分的模块，块的入口模块等。就像 <code>ModuleGraph</code> 一样， <code>ChunkGraph</code> 在具有以下签名的映射的帮助下跟踪这些具有其他属性的块： <code>WeakMap&lt;Chunk, ChunkGraphChunk&gt;</code> 。与 <code>ModuleGraph</code> 的映射相比， <code>ChunkGraph</code> 维护的此映射不包含有关块之间连接的信息。相反，所有必要的信息（例如它所属的 <code>ChunkGroup</code> s）都保存在块本身中。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>💡请记住，块（chunks）在 <code>ChunkGroups</code> 中组合在一起，在这些chunk groups之间可以存在<strong>父子关系</strong>（正如我们在上图中看到的那样）。模块不是这种情况，因为模块可以相互依赖，但没有严格的父模块概念。</p></div><p>现在让我们尝试在自定义插件中使用 <code>ChunkGraph</code> ，以便更好地理解它。请注意，我们正在考虑的这个例子是上图描述的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> path </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">path</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 为了显示chunk groups之间的 父-子关系</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 这里我们进行打印</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> printWithLeftPadding </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">paddingLength</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(message</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">padStart</span><span style="color:#A6ACCD;">(message</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> paddingLength))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UnderstandingChunkGraphPlugin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">apply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compiler</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">className</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">compiler</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">compilation</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">className</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">compilation</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// \`afterChunks\` 在 \`ChunkGraph\` 构建后调用</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">compilation</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">afterChunks</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">className</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">chunks</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// \`chunks\` 是所有创建的chunks的集合</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// chunks按照其创建的顺序添加到这个集合中</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// console.log(chunks)</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 正如之前提到的，\`compilation\` 对象包含bundling过程的状态</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 🚀 在这里，我们还可以找到所有已创建的\`ChunkGroup\`(包括\`Entrypoint\`实例)。</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// console.log(compilation.chunkGroups)</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 📚 \`EntryPoint\` 是 \`ChunkGroup\` 的一种特殊类型</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 它从 \`entry\` 对象每一项中创建，在本例子中，存在2个EntryPoint</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 因此，为了遍历 \`ChunkGroup\`，我们必须从 \`EntryPoint\` 开始遍历，它存在于 \`compilation\` 对象中</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 关于 \`entrypoints\` map(&lt;string, Entrypoint&gt;) 可以查看 https://github.com/webpack/webpack/blob/main/lib/Compilation.js#L987</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">entrypoints</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">compilation</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 关于 \`chunkMap\`(&lt;Chunk, ChunkGraphChunk&gt;)可查看：https://github.com/webpack/webpack/blob/main/lib/ChunkGraph.js#L226-L227</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> chunkGraph</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> _chunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">chunkMap</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">compilation</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">printChunkGroupsInformation</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">chunkGroup</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">paddingLength</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#82AAFF;">printWithLeftPadding</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Current ChunkGroup&#39;s name: </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">chunkGroup</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">;</span><span style="color:#89DDFF;">\`</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paddingLength</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#82AAFF;">printWithLeftPadding</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Is current ChunkGroup an EntryPoint? - </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">chunkGroup</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Entrypoint</span><span style="color:#89DDFF;">&#39;}\`</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paddingLength</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">          </span></span>
<span class="line"><span style="color:#F07178;">          </span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// \`chunkGroup.chunks\` - 一个ChunkGroup可以包含一个或多个chunks</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">allModulesInChunkGroup</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">chunkGroup</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">chunks</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">flatMap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">c</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 为了获取单一chunk中包含的modules，可使用\`ChunkGraph\`存储的信息</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">associatedGraphChunk</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">chunkMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">              </span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 这里面也包含 *入口模块（entry modules）*</span></span>
<span class="line"><span style="color:#89DDFF;">                </span><span style="color:#676E95;font-style:italic;">// 因为 \`.modules\` 是一个Set集合，所以使用展开符</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">associatedGraphChunk</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">modules</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">              </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// module资源是一个绝对路径</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 但我们只关心该模块的文件名</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">module</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">basename</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">module.</span><span style="color:#A6ACCD;">resource</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#82AAFF;">printWithLeftPadding</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">The modules that belong to this chunk group: </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">allModulesInChunkGroup</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">, </span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}\`</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paddingLength</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#A6ACCD;">\\n</span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// 💡 \`ChunkGroup\` 也可以有子的 \`ChunkGroup\`</span></span>
<span class="line"><span style="color:#F07178;">          [</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">chunkGroup</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_children</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">childChunkGroup</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">printWithLeftPadding</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">childChunkGroup</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paddingLength</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">entryPointName</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">entryPoint</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">entrypoints</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#82AAFF;">printChunkGroupsInformation</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">entryPoint</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这个例子可以在 <a href="https://stackblitz.com/edit/node-nlpz6x?file=webpack.config.js" target="_blank" rel="noreferrer">StackBlitz</a> 上查看，运行 <code>npm run build</code> 后，您应该看到以下输出：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Current</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ChunkGroup</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">s name: foo;</span></span>
<span class="line"><span style="color:#C3E88D;">Is current ChunkGroup an EntryPoint? - true</span></span>
<span class="line"><span style="color:#C3E88D;">The modules that belong to this chunk group: a.js, b.js, a1.js, b1.js</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C3E88D;">Current ChunkGroup</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">s</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">name:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">Is</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">current</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ChunkGroup</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">an</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">EntryPoint?</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#FFCB6B;">The</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">modules</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">that</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">belong</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">to</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">chunk</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">group:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">c.js,</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">common.js</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">Current</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ChunkGroup</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">s name: c1;</span></span>
<span class="line"><span style="color:#C3E88D;">   Is current ChunkGroup an EntryPoint? - false</span></span>
<span class="line"><span style="color:#C3E88D;">   The modules that belong to this chunk group: c1.js</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C3E88D;">   Current ChunkGroup</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">s</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">name:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">c2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">Is</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">current</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ChunkGroup</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">an</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">EntryPoint?</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">The</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">modules</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">that</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">belong</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">to</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">chunk</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">group:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">c2.js</span></span></code></pre></div><p>我们使用缩进来区分父子关系。我们还可以注意到输出与图相当，因此我们可以确定遍历的正确性。</p><h2 id="生成chunk资源" tabindex="-1">生成chunk资源 <a class="header-anchor" href="#生成chunk资源" aria-label="Permalink to &quot;生成chunk资源&quot;">​</a></h2><p>值得一提的是，生成的文件不仅仅是原始文件的复制粘贴版本，因为为了实现其功能，webpack 需要添加一些自定义代码，使一切按预期工作。</p><p>这就引出了一个问题，<strong>即webpack如何知道要生成什么代码</strong>。这一切都从最基本（也是最有用）的层开始 - <code>module</code> 。模块可以导出成员，导入其他成员，使用动态导入，使用特定于 webpack 的函数（例如 <code>require.resolve</code> ）等。根据模块的源代码，webpack 可以确定要生成哪些代码以实现所需的功能。此发现在 AST 分析期间开始，在该分析中找到依赖项。尽管到目前为止，我们一直在互换使用依赖（<code>dependencies</code>）和模块（<code>modules</code>），但底层情况要复杂一些。</p><p>🌰例如，一个简单的 <code>import { aFunction } from &#39;./foo&#39;</code> 将导致2个依赖项（一个用于 <code>import</code> 语句本身，另一个用于说明符，即 <code>aFunction</code> ），将从中创建单个模块。另一个例子是 <code>import()</code> 函数。正如前面各节所述，这将导致异步依赖项块，其中一个依赖项是 <code>ImportDependency</code> ，它特定于动态导入。</p><p>这些依赖项是<em>必不可少的</em>，因为它们带有一些关于应生成哪些代码的<strong>提示</strong>。例如， <code>ImportDependency</code> 确切地知道要告诉 webpack 什么，以便异步获取导入的模块并使用其导出的成员。这些提示可以称为<strong>运行时要求(<code>runtime requirements</code>)</strong>。例如，如果模块导出其某些成员，则会有一些依赖关系（回想一下我们现在不是指<strong>模块</strong>），即 <code>HarmonyExportSpecifierDependency</code> ，这将通知webpack它需要处理导出成员的逻辑。</p><p>总而言之，模块将附带其<strong>运行时要求</strong>，这取决于该模块在其源代码中使用的内容。区块(<code>chunk</code>)的运行时需求将是属于该区块的<strong>所有</strong>模块的所有运行时要求的集合。现在 webpack 知道了一个块的所有需求，它将能够正确生成运行时代码。</p><p>这也称为渲染过程，我们将在专门的文章中详细讨论它。现在，理解渲染过程严重依赖 <code>ChunkGraph</code> 就足够了，因为它包含块组（即 <code>ChunkGroup</code> 、 <code>EntryPoint</code> ），其中包含块，而chunk groups又包含了模块（<code>modules</code>），这些模块以精细的方式包含有关将由 webpack 生成的运行时(<code>runtime</code>)代码的信息和提示。</p><p>本节标志着本文理论部分的结束。在下一节中，我们将看到一些调试 webpack 源代码的方法，当你处理问题或只是想了解有关 webpack工作原理的更多信息时，这些方法都会派上用场。</p><h2 id="vscode-stackblitz调试源码" tabindex="-1">VSCode + StackBlitz调试源码 <a class="header-anchor" href="#vscode-stackblitz调试源码" aria-label="Permalink to &quot;VSCode + StackBlitz调试源码&quot;">​</a></h2><p>省略，查看原文</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在本文中，我试图包含尽可能多的信息，而不是多余的细节，以便您从不同的角度看待 webpack。这是一个复杂（且引人入胜）的工具，这篇文章旨在将其分解为更小且易于消化的部分。</p><p>2023年05月09日11:01:01</p>`,126),C=[d];function A(u,h,g,m,b,k){return a(),n("div",null,C)}const G=s(i,[["render",A]]);export{f as __pageData,G as default};
