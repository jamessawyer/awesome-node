import{_ as e,c as o,o as a,V as t}from"./chunks/framework.478efc10.js";const d="/awesome-node/assets/stream-cheatsheet-1.3fb926c3.png",c="/awesome-node/assets/stream-cheatsheet-2.e6221828.png",f=JSON.parse('{"title":"Node Streams","description":"","frontmatter":{"title":"Node Streams"},"headers":[],"relativePath":"core/stream/index.md","lastUpdated":1681982037000}'),i={name:"core/stream/index.md"},s=t('<p>可以说Streams是Node.js的灵魂。下面介绍一些关于好的学习资源。</p><h2 id="cheatsheet" tabindex="-1">cheatsheet <a class="header-anchor" href="#cheatsheet" aria-label="Permalink to &quot;cheatsheet&quot;">​</a></h2><p>关于流的cheatsheet: <a href="https://devhints.io/nodejs-stream" target="_blank" rel="noreferrer">Nodejs Streams cheatsheet @devhints.io</a><img src="'+d+'" alt="Stream Cheatsheet1"><img src="'+c+'" alt="Stream Cheatsheet2"></p><h2 id="文章" tabindex="-1">文章 <a class="header-anchor" href="#文章" aria-label="Permalink to &quot;文章&quot;">​</a></h2><ol><li><a href="./stream-visualization.html">A Visual Guide to NodeJS Streams — Advanced NodeJS Part 4</a><ul><li>通过可视化的方式了解Node中 <code>Readable</code> &amp; <code>Writable</code> &amp; <code>Duplex</code> &amp; <code>Transform</code> 4种流</li><li>如何使用 <code>Readable</code> 流的 <code>pipe()</code> 方法将其它流管道连接起来</li><li><code>Readable</code> &amp; <code>Writable</code> 流内部 <code>highWaterMark</code> 的含义以及作用，什么是 <code>背压</code></li><li><code>fs.createWritableStream</code> 会创建一个可读流，但是它是处于 <code>暂停</code> 状态的，当通过 <code>pipe()</code> 连接到其它的流时，可读流将变为 <code>流动</code> 模式</li><li>如果使用管道对一份可读流进行多次拷贝</li><li>使用流进行图片压缩的具体实例，将一个可读流连接到转换流，再连接到可写流</li></ul></li><li><a href="./stream-in-practice.html">NodeJS Streams in Practice — Advanced NodeJS Part 5</a> 流在实际应用中使用示例 <ul><li><code>Readable</code> 各种事件的触发时机，以及事件之间的关联关系</li><li><code>Readable</code> 的2种模式 - 流动模式（<code>flowing mode</code>） &amp; 暂停模式（<code>paused mode</code>）；以及2种模式之间如何进行相互的转换</li><li><code>Readable</code> 的 <code>pipe()</code> 方法，将多个流进行连接</li><li>http模块中的 <code>IncomingMessage</code> &amp; <code>OutgoingMessage</code> 以及 <code>Socket</code> 本质上都是流</li><li><code>pipeline()</code> 方法对于错误处理的优势，而 <code>pipe()</code> 方法则对于错误处理不是很方便，因此尽可能的使用 <code>pipeline()</code> 将多个流进行连接</li><li>通过将http请求进行Hash运算后返回的例子，展示使用 <code>pipeline()</code> 将 <code>可读流 - 转换流 - 可写流</code> 进行连接</li><li><code>crypto</code> 模块的 <code>createHash</code> 本质上是一种转换流</li></ul></li></ol>',5),l=[s];function r(n,h,p,m,_,u){return a(),o("div",null,l)}const b=e(i,[["render",r]]);export{f as __pageData,b as default};
