import{_ as n,c as l,o,V as a}from"./chunks/framework.92797c73.js";const e="/awesome-node/assets/16-1.4d11aaf4.webp",p="/awesome-node/assets/16-2.563da688.webp",c="/awesome-node/assets/16-3.54a3b9fe.webp",s="/awesome-node/assets/16-4.28dd8a62.webp",t="/awesome-node/assets/16-5.ec509710.webp",i="/awesome-node/assets/16-6.19195347.webp",g=JSON.parse('{"title":"SplitChunks","description":"","frontmatter":{"title":"SplitChunks"},"headers":[],"relativePath":"book/webpack/16.md","lastUpdated":1681888359000}'),r={name:"book/webpack/16.md"},d=a('<p>Webpack 默认会将尽可能多的模块代码打包在一起，优点是能减少最终页面的 HTTP 请求数，但缺点也很明显：</p><ul><li>页面初始代码包过大，影响首屏渲染性能；</li><li>无法有效应用浏览器缓存，特别对于 NPM 包这类变动较少的代码，业务代码哪怕改了一行都会导致 NPM 包缓存失效。</li></ul><p>为此，Webpack 提供了 <code>SplitChunksPlugin</code> 插件，专门用于根据产物包的体积、引用次数等做分包优化，规避上述问题，特别适合生产环境使用。</p><p>不过，<code>SplitChunksPlugin</code> 的使用方法比较复杂，我们得从 Chunk 这个概念开始说起。</p><ul><li><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noreferrer">webpack SplitChunkPlugin doc</a></li></ul><h2 id="深入理解chunk" tabindex="-1">深入理解Chunk <a class="header-anchor" href="#深入理解chunk" aria-label="Permalink to &quot;深入理解Chunk&quot;">​</a></h2><p><code>Chunk</code> 是 Webpack 内部一个非常重要的底层设计，用于组织、管理、优化最终产物，在构建流程进入生成(Seal)阶段后：</p><ul><li>Webpack 首先根据 <code>entry</code> 配置创建若干 Chunk 对象；</li><li>遍历构建(Make)阶段找到的所有 Module 对象，同一 Entry 下的模块分配到 Entry 对应的 Chunk 中；</li><li>遇到异步模块则创建新的 Chunk 对象，并将异步模块放入该 Chunk；</li><li>分配完毕后，根据 SplitChunksPlugin 的启发式算法进一步对这些 Chunk 执行<strong>裁剪、拆分、合并、代码调优</strong>，最终调整成运行性能(可能)更优的形态；</li><li>最后，将这些 Chunk 一个个输出成最终的产物(Asset)文件，编译工作到此结束。</li></ul><p><img src="'+e+'" alt="modules to chunks"></p><p>📚可以看出，Chunk 在构建流程中起着承上启下的关键作用:</p><ol><li>一方面作为 Module 容器，根据一系列默认 <strong>分包策略</strong> 决定哪些模块应该合并在一起打包；</li><li>另一方面根据 <code>splitChunks</code> 设定的 <strong>策略</strong> 优化分包，决定最终输出多少产物文件。</li></ol><p><strong>Chunk 分包结果的好坏直接影响了最终应用性能</strong>，Webpack 默认会将以下三种模块做分包处理：</p><ol><li><code>Initial Chunk</code>：<code>entry</code> 模块及相应子模块打包成 Initial Chunk；</li><li><code>Async Chunk</code>：通过 <code>import(&#39;./xx&#39;)</code> 等语句导入的异步模块及相应子模块组成的 Async Chunk；</li><li><code>Runtime Chunk</code>：运行时代码抽离成 Runtime Chunk，可通过 <a href="https://webpack.js.org/configuration/entry-context/#dependencies" target="_blank" rel="noreferrer">entry.runtime</a> 配置项实现。</li></ol><p>Runtime Chunk 规则比较简单，本文先不关注，但 Initial Chunk 与 Async Chunk 这种略显粗暴的规则会带来两个明显问题</p><h3 id="模块重复打包" tabindex="-1">模块重复打包 <a class="header-anchor" href="#模块重复打包" aria-label="Permalink to &quot;模块重复打包&quot;">​</a></h3><p>假如多个 Chunk 同时依赖同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk，例如对于下面的模块关系：</p><p><img src="'+p+'" alt="modules关系"></p><p>示例中 <code>main/index</code> 入口(<code>entry</code>)同时依赖于 <code>c</code> 模块，默认情况下 Webpack 不会对此做任何优化处理，只是单纯地将 <code>c</code> 模块同时打包进 <code>main/index</code> 两个 Chunk😅：</p><p><img src="'+c+`" alt="打包chunks结果"></p><h3 id="资源冗余-低效缓存" tabindex="-1">资源冗余 &amp; 低效缓存 <a class="header-anchor" href="#资源冗余-低效缓存" aria-label="Permalink to &quot;资源冗余 &amp; 低效缓存&quot;">​</a></h3><p>Webpack 会将 Entry 模块、异步模块所有代码都打进同一个单独的包，这在小型项目通常不会有明显的性能问题，但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端：</p><ol><li><strong>资源冗余</strong>：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码</li><li><strong>缓存失效</strong>：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低</li></ol><p>这两个问题都可以通过更科学的分包策略解决，例如：</p><ol><li>将被多个 Chunk 依赖的包分离成独立 Chunk，防止资源重复；</li><li><code>node_modules</code> 中的资源通常变动较少，可以抽成一个独立的包，业务代码的频繁变动不会导致这部分第三方库资源缓存失效，被无意义地重复加载。</li></ol><p>为此，Webpack 专门提供了 <code>SplitChunksPlugin</code> 插件，用于实现更灵活、可配置的分包，提升应用性能。</p><h2 id="splitchunksplugin简介" tabindex="-1">SplitChunksPlugin简介 <a class="header-anchor" href="#splitchunksplugin简介" aria-label="Permalink to &quot;SplitChunksPlugin简介&quot;">​</a></h2><p><code>SplitChunksPlugin</code>是 Webpack 4 之后内置实现的最新分包方案，与 Webpack3 时代的 <code>CommonsChunkPlugin</code> 相比，它能够基于一些更灵活、合理的启发式规则将 Module 编排进不同的 Chunk，最终构建出性能更佳，缓存更友好的应用产物。</p><p><code>SplitChunksPlugin</code> 的用法比较抽象，算得上 Webpack 的一个难点，主要能力有：</p><ul><li><code>SplitChunksPlugin</code> 支持根据 Module 路径、Module 被引用次数、Chunk 大小、Chunk 请求数等决定是否对 Chunk 做进一步拆解，这些决策都可以通过 <code>optimization.splitChunks</code> 相应配置项调整定制，基于这些能力我们可以实现： <ul><li>单独打包某些特定路径的内容，例如 <code>node_modules</code> 打包为 <code>vendors</code>；</li><li>单独打包使用频率较高的文件；</li></ul></li><li><code>SplitChunksPlugin</code> 还提供了 <code>optimization.splitChunks.cacheGroup</code> 概念，用于对不同特点的资源做分组处理，并为这些分组设置更有针对性的分包规则；</li><li><code>SplitChunksPlugin</code> 还内置了 <code>default</code> 与 <code>defaultVendors</code> 两个 <code>cacheGroup</code>，提供一些开箱即用的分包特性： <ul><li><code>node_modules</code> 资源会命中 <code>defaultVendors</code> 规则，并被单独打包；</li><li>只有包体超过 30kb 的 Chunk 才会被单独打包；</li><li>加载 Async Chunk 所需请求数不得超过 30；</li><li>加载 Initial Chunk 所需请求数不得超过 30。</li></ul></li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>这里所说的请求数不能等价对标到 http 资源请求数，下面会细讲。</p></div><p>由于 Webpack4 开始已经内置支持 <code>SplitChunksPlugin</code> ，我们不需要额外安装依赖，直接修改 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimizationsplitchunks" target="_blank" rel="noreferrer">optimization.splitChunks</a> 配置项即可实现自定义的分包策略：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><code>splitChunks</code> 主要有两种类型的配置：</p><ul><li><code>minChunks/minSize/maxInitialRequest</code> 等分包条件，满足这些条件的模块都会被执行分包；</li><li><code>cacheGroup</code> ：用于为特定资源声明特定分包条件，例如可以为 <code>node_modules</code> 包设定更宽松的分包条件。</li></ul><details class="details custom-block"><summary>Claude关于minSize/minChunks/maxInitialRequest解释</summary><p>minSize、maxSize 和 minChunks 都是 SplitChunksPlugin 中很重要的拆分规则配置。它们的用法如下:</p><p><strong>minSize</strong>: 提取的 chunk 最小大小,默认为 30000(30kb)。</p><ul><li>作用: 防止提取出来的 chunk 体积太小,导致 HTTP 请求数量过多。</li><li>配置建议: 根据项目的体积扩容阈值设置一个合理的值。一般不小于 30kb。</li></ul><p><strong>maxSize</strong>: 提取的 chunk 最大大小,默认为 0,表示无限制。</p><ul><li>作用: 防止提取出的单一 chunk 体积过大,体验不佳。</li><li>配置建议: 可以设置为 600kb 到 1000kb 之间的一个值。具体根据项目情况配置。</li></ul><p><strong>minChunks</strong>: 模块至少在 minChunks 中重复出现,才会被提取到缓存组。默认为 1。</p><ul><li>作用: 控制被提取模块的重复率,避免 appeared-once 现象。</li><li>配置建议: 一般设置为 2 或 3。不能设置过大,否则公共模块提取不出来,失去优化意义。</li></ul><p>这三个规则的关系可以描述为:<strong>Extractor = minSize &lt;= chunkSize &lt;= maxSize &amp;&amp; occurrences &gt;= minChunks</strong>也就是当模块体积在 minSize 和 maxSize 范围内,且其出现次数不小于 minChunks 时,才会被 SplitChunksPlugin 提取到缓存组中。</p><p>通过均衡地配置这三个值,可以实现:</p><ol><li>避免请求过多导致的性能损耗;</li><li>提取出合理体积的 chunk,既不会文件过小导致的请求浪费,也不会文件过大导致的加载慢;</li><li>选择出现频率高的模块进行提取,获得最大的优化效果。这三个规则的灵活运用,是使用 SplitChunksPlugin 优化代码的关键。理解每个规则的作用及其之间的关系,可以更好地配置出满足需求的拆分结果。</li></ol></details><h3 id="设置分包范围" tabindex="-1">设置分包范围 <a class="header-anchor" href="#设置分包范围" aria-label="Permalink to &quot;设置分包范围&quot;">​</a></h3><p>首先，<code>SplitChunksPlugin</code> 默认情况下只对 Async Chunk 生效，我们可以通过 <code>splitChunks.chunks</code> 调整作用范围，该配置项支持如下值：</p><ul><li>字符串 <code>&#39;all&#39;</code> ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值；</li><li>字符串 <code>&#39;initial&#39;</code> ：只对 Initial Chunk 生效；</li><li>字符串 <code>&#39;async&#39;</code> ：只对 Async Chunk 生效；</li><li>函数 <code>(chunk) =&gt; boolean</code> ：该函数返回 <code>true</code> 时生效；</li></ul><p>🌰</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">chunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">all</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>设置为 <code>all</code> 效果最佳，此时 Initial Chunk、Async Chunk 都会被 <code>SplitChunksPlugin</code> 插件优化。</p><h3 id="根据-module-使用频率分包" tabindex="-1">根据 Module 使用频率分包 <a class="header-anchor" href="#根据-module-使用频率分包" aria-label="Permalink to &quot;根据 Module 使用频率分包&quot;">​</a></h3><p><code>SplitChunksPlugin</code> 支持按 Module 被 Chunk 引用的次数决定是否分包，借助这种能力我们可以轻易将那些被频繁使用的</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 设定引用次数超过 2 的模块才进行分包</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">minChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>🚨注意，这里“<strong>被 Chunk 引用次数</strong>”并不直接等价于被 <code>import</code> 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// common.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">common chunk</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// async-module.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> common </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./common</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// entry-a.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> common </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./common</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./async-module</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// entry-b.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> common </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./common</span><span style="color:#89DDFF;">&#39;</span></span></code></pre></div><p>上例包含四个模块，形成如下模块关系图：</p><p><img src="`+s+`" alt="模块关系图"></p><p>其中，<code>entry-a</code>、<code>entry-b</code> 分别被视作 Initial Chunk 处理；<code>async-module</code> 被 <code>entry-a</code> 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 <code>common</code> 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，配合下面的配置：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-F9D8u" id="tab-CXXSzNl" checked="checked"><label for="tab-CXXSzNl">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">entry1</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./src/entry-a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">entry2</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./src/entry-b.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">minChunk</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div></div><p><code>common</code> 模块命中 <code>optimization.splitChunks.minChunks = 2</code> 规则，因此该模块<strong>可能</strong>会被单独分包，最终产物：</p><ul><li><code>entry1.js</code></li><li><code>entry1.js</code></li><li><code>async-module.js</code></li><li><code>common.js</code></li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>强调一下，上面说的是“<strong>可能</strong>”，<code>minChunks</code> 并不是唯一条件，此外还需要满足诸如 <code>minSize</code>、<code>chunks</code> 等限制条件才会真正执行分包，接着往下看。</p></div><ul><li>🌰 <a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/splitchunks-basic/webpack.config.js" target="_blank" rel="noreferrer">splitChunks-basic - @github</a></li></ul><h3 id="限制分包数量" tabindex="-1">限制分包数量 <a class="header-anchor" href="#限制分包数量" aria-label="Permalink to &quot;限制分包数量&quot;">​</a></h3><p>在 <code>minChunks</code> 基础上，为防止最终产物文件数量过多导致 HTTP 网络请求数剧增，反而降低应用性能，Webpack 还提供了 <code>maxInitialRequest/maxAsyncRequest</code> 配置项，用于限制分包数量：</p><ul><li><code>maxInitialRequests</code>：用于设置 Initial Chunk 最大并行请求数；</li><li><code>maxAsyncRequests</code>：用于设置 Async Chunk 最大并行请求数。</li></ul><blockquote><p>👩‍🏫敲重点，<strong>&quot;请求数&quot;</strong> 这个概念有点复杂：</p></blockquote><p>这里所说的“请求数”，是指加载一个 Chunk 时所需要加载的所有分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子 Chunk A[¡]，那么加载 A 时，浏览器需要同时加载所有的 A[¡]，此时并行请求数等于 ¡ 个分包加 A 主包，即 <code>¡+1</code>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>通过 <a href="https://webpack.js.org/api/compilation-object/#emitasset" target="_blank" rel="noreferrer">emitAssets</a> 等方式直接输出产物文件不在此范畴。</p></div><p>1️⃣ 举个例子，对于上例所说的模块关系：</p><p><img src="`+t+'" alt="modules关系"></p><p>若 <code>minChunks = 2</code> ，则 <code>common</code> 模块命中 <code>minChunks</code> 规则被独立分包，浏览器请求 <code>entry-a</code> 时，则需要同时请求 <code>common</code> 包，并行请求数为 1 + 1=2。</p><p>2️⃣而对于下述模块关系：</p><p><img src="'+i+'" alt="modules关系"></p><p>若 <code>minChunks = 2</code> ，则 <code>common-1</code> 、<code>common-2</code> 同时命中 <code>minChunks</code> 规则被分别打包，浏览器请求 <code>entry-b</code> 时需要同时请求 <code>common-1</code> 、<code>common-2</code> 两个分包，并行数为 2 + 1 = 3，此时若 <code>maxInitialRequest = 2</code>，则分包数超过阈值，<code>SplitChunksPlugin</code> 会 <strong>放弃 <code>common-1</code>、<code>common-2</code> 中体积较小的分包</strong>。<code>maxAsyncRequest</code> 逻辑与此类似，不在赘述。</p><p>并行请求数关键逻辑总结如下：</p><ul><li>Initial Chunk 本身算一个请求；</li><li>Async Chunk 不算并行请求；</li><li>通过 <code>runtimeChunk</code> 拆分出的 runtime 不算并行请求；</li><li>如果同时有两个 Chunk 满足拆分规则，但是 <code>maxInitialRequests</code>(或 <code>maxAsyncRequest</code>) 的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解。😎</li></ul><h3 id="限制分包体积" tabindex="-1">限制分包体积 <a class="header-anchor" href="#限制分包体积" aria-label="Permalink to &quot;限制分包体积&quot;">​</a></h3><p>除上面介绍的 <code>minChunks</code> —— 模块被引用次数，以及 <code>maxXXXRequest</code> —— 包数量，这两个条件外，Webpack 还提供了一系列与 Chunk 大小有关的分包判定规则，借助这些规则我们可以实现当包体过小时直接取消分包 —— 防止产物过&quot;碎&quot;；当包体过大时尝试对 Chunk 再做拆解 —— 避免单个 Chunk 过大。</p><p>这一规则相关的配置项有：</p><ul><li><code>minSize</code>： 超过这个尺寸的 Chunk 才会正式被分包；</li><li><code>maxSize</code>： 超过这个尺寸的 Chunk 会尝试<strong>进一步</strong>拆分出更小的 Chunk；</li><li><code>maxAsyncSize</code>： 与 <code>maxSize</code> 功能类似，但只对异步引入的模块生效；</li><li><code>maxInitialSize</code>： 与 <code>maxSize</code> 类似，但只对 <code>entry</code> 配置的入口模块生效；</li><li><code>enforceSizeThreshold</code>： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 Size 限制。</li></ul><p>🎉那么，结合前面介绍的两种规则，<code>SplitChunksPlugin</code> 的主体流程如下：</p><ol><li><code>SplitChunksPlugin</code> 尝试将命中 <code>minChunks</code> 规则的 Module 统一抽到一个额外的 Chunk 对象；</li><li>判断该 Chunk 是否满足 <code>maxInitialRequests</code> 阈值，若满足则进行下一步；</li><li>判断该 Chunk 资源的体积是否大于上述配置项 <code>minSize</code> 声明的下限阈值； <ul><li>如果体积<strong>小于</strong> <code>minSize</code> 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk</li><li>如果 Chunk 体积<strong>大于</strong> <code>minSize</code> 则判断是否超过 <code>maxSize</code>、<code>maxAsyncSize</code>、<code>maxInitialSize</code> 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分</li></ul></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>虽然 <code>maxSize</code> 等阈值规则会产生更多的包体，但缓存粒度会更小，命中率相对也会更高，配合持久缓存与 HTTP2 的多路复用能力，网络性能反而会有正向收益。</p></div><p>🌰以上述模块关系为例：</p><p><img src="'+s+`" alt="模块关系图"></p><p>若此时 Webpack 配置的 <code>minChunks</code> 大于 2，且 <code>maxInitialRequests</code> 也同样大于 2，如果 <code>common</code> 模块的体积大于上述说明的 <code>minSize</code> 配置项则分包成功，<code>common</code> 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>注意，这些条件的优先级顺序为： <code>maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize</code>。而命中 <code>enforceSizeThreshold</code> 阈值的 Chunk 会直接跳过这些条件判断，强制进行分包。</p></div><h3 id="缓存组-cachegroups-简介" tabindex="-1">缓存组 <code>cacheGroups</code> 简介 <a class="header-anchor" href="#缓存组-cachegroups-简介" aria-label="Permalink to &quot;缓存组 \`cacheGroups\` 简介&quot;">​</a></h3><p>上述 <code>minChunks</code>、<code>maxInitialRequest</code>、<code>minSize</code> 都属于<strong>分包条件</strong>，决定是否对什么情况下对那些 Module 做分包处理。此外， <code>SplitChunksPlugin</code> 还提供了 <code>cacheGroups</code> 配置项用于为不同文件组设置不同的规则，例如：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-IkvfA" id="tab--xHKJ6o" checked="checked"><label for="tab--xHKJ6o">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">cacheGroups</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">vendors</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">test</span><span style="color:#89DDFF;">:</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/[</span><span style="color:#A6ACCD;">\\\\</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">]</span><span style="color:#C3E88D;">node_modules</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">\\\\</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">]/</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">minChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">minSize</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div></div></div><p>示例通过 <code>cacheGroups</code> 属性设置 <code>vendors</code> 缓存组，所有命中 <code>vendors.test</code> 规则的模块都会被归类 <code>vendors</code> 分组，优先应用该组下的 <code>minChunks</code>、<code>minSize</code> 等分包配置。</p><p><code>cacheGroups</code> 支持上述 <code>minSize/minChunks/maxInitialRequest</code> 等条件配置，此外还支持一些与分组逻辑强相关的属性，包括：</p><ul><li><code>test</code>：接受正则表达式、函数及字符串，所有符合 <code>test</code> 判断的 Module 或 Chunk 都会被分到该组；</li><li><code>type</code>：接受正则表达式、函数及字符串，与 <code>test</code> 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 <code>type = &#39;json&#39;</code> 会命中所有 JSON 文件；</li><li><code>idHint</code>：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 <code>idHint = &#39;vendors&#39;</code> 时，输出产物文件名形如 <code>vendors-xxx-xxx.js</code> ；</li><li><code>priority</code>：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 <code>priority</code> 更大的组。</li></ul><p>缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有 <code>node_modules</code> 下的模块统一打包到 <code>vendors</code> 产物，从而实现第三方库与业务代码的分离。</p><p>Webpack 提供了两个开箱即用的 <code>cacheGroups</code>，分别命名为 <code>default</code> 与 <code>defaultVendors</code>，默认配置：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-waURv" id="tab-r4YOd1e" checked="checked"><label for="tab-r4YOd1e">webpack.config.js</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">cacheGroups</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">idHint</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">reuseExistingChunk</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">minChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">priority</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">20</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">defaultVendors</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">idHint</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vendors</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">reuseExistingChunk</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">test</span><span style="color:#89DDFF;">:</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/[</span><span style="color:#A6ACCD;">\\\\</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">]</span><span style="color:#C3E88D;">node_modules</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">\\\\</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">]/</span><span style="color:#F78C6C;">i</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#F07178;">priority</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div></div></div><p>这两个配置组能帮助我们：</p><ul><li>将所有 <code>node_modules</code> 中的资源单独打包到 <code>vendors-xxx-xx.js</code> 命名的产物</li><li>对引用次数大于等于 2 的模块 —— 也就是被多个 Chunk 引用的模块，单独打包</li></ul><p>开发者也可以将默认分组设置为 false，关闭分组配置，例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">cacheGroups</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h2 id="配置项与最佳实践" tabindex="-1">配置项与最佳实践 <a class="header-anchor" href="#配置项与最佳实践" aria-label="Permalink to &quot;配置项与最佳实践&quot;">​</a></h2><p>最后，我们再回顾一下 <code>SplitChunksPlugin</code> 支持的配置项：</p><ul><li><code>minChunks</code>：用于设置引用阈值，被引用次数超过该阈值的 Module 才会进行分包处理；</li><li><code>maxInitialRequest/maxAsyncRequests</code>：用于限制 Initial Chunk(或 Async Chunk) 最大并行请求数，本质上是在限制最终产生的分包数量；</li><li><code>minSize</code>： 超过这个尺寸的 Chunk 才会正式被分包；</li><li><code>maxSize</code>： 超过这个尺寸的 Chunk 会尝试继续做分包；</li><li><code>maxAsyncSize</code>： 与 <code>maxSize</code> 功能类似，但只对异步引入的模块生效；</li><li><code>maxInitialSize</code>： 与 <code>maxSize</code> 类似，但只对 <code>entry</code> 配置的入口模块生效；</li><li><code>enforceSizeThreshold</code>： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制；</li><li><code>cacheGroups</code>：用于设置缓存组规则，为不同类型的资源设置更有针对性的分包策略。</li></ul><p>结合这些特性，业界已经总结了许多惯用的最佳分包策略，包括：</p><ul><li>针对 <code>node_modules</code> 资源： <ul><li>可以将 <code>node_modules</code> 模块打包成单独文件(通过 <code>cacheGroups</code> 实现)，防止业务代码的变更影响 NPM 包缓存，同时建议通过 <code>maxSize</code> 设定阈值，防止 vendor 包体过大；</li><li>更激进的，如果生产环境已经部署 HTTP2/3 一类高性能网络协议，甚至可以考虑将每一个 NPM 包都打包成单独文件，具体实现可查看小册<a href="https://github1s.com/Tecvan-fe/webpack-book-samples/blob/50c9a47ce3/splitchunks-seperate-npm/webpack.config.js#L19-L20" target="_blank" rel="noreferrer">示例</a>；</li></ul></li><li>针对业务代码： <ul><li>设置 <code>common</code> 分组，通过 <code>minChunks</code> 配置项将使用率较高的资源合并为 Common 资源；</li><li>首屏用不上的代码，尽量以异步方式引入；</li><li>设置 <code>optimization.runtimeChunk</code> 为 <code>true</code>，将运行时代码拆分为独立资源。</li></ul></li></ul><p>不过，现实世界很复杂，同样的方法放在不同场景可能会有完全相反的效果，建议你根据自己项目的实际情况(代码量、基础设施环境)，择优选用上述实践。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Chunk 是 Webpack 实现模块打包的关键设计，Webpack 会首先为 Entry 模块、异步模块、Runtime 模块(取决于配置) 创建 Chunk 容器，之后按照 <code>splitChunks</code> 配置进一步优化、裁剪分包内容。</p><p><code>splitChunks</code> 规则比较复杂，大致上可以分类为：</p><ul><li>规则类：如 <code>minSize/minChunks</code> 等，匹配这些条件的 Module 都会被单独分包；</li><li><code>cacheGroup</code>：可以理解为针对特定资源的次级规则集合。</li></ul><p>实践中，分包策略的好坏直接影响应用的运行性能，常用策略一是单独打包 <code>node_modules</code> 代码(习惯称为 <code>vendor</code>)，二是单独打包被频繁使用的模块(习惯称为 <code>common</code>)。</p><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p><code>SplitChunksPlugin</code> 的用法比较复杂，建议你尝试写一些 demo，组合各种形态的配置值，深入理解配置项背后的隐晦逻辑。</p><details class="details custom-block"><summary>SplitChunksPlugin实现chunks拆分的原理</summary><ol><li>分析模块之间的依赖关系,找到可以被提取出来的模块。</li><li>根据配置的规则,决定这些模块应该放到哪个缓存组中。</li><li>根据缓存组的配置,将这些模块提取出来,形成一个单独的 chunk。</li><li>将原来的 chunks 中的模块替换为该 chunk 的引用。</li><li>在页面中加载这个新生成的 chunk。</li></ol><p>具体的实现过程如下:</p><ol><li>在编译阶段的优化钩子函数中,对所有模块及其依赖进行深度优先遍历。</li><li>根据 minSize、maxSize 和 minChunks 等规则过滤掉不符合条件的模块。</li><li>对符合条件的模块,根据 module 和 chunks 的名称、来源等属性决定它属于哪个缓存组。每个模块只能属于一个缓存组。</li><li>遍历所有的缓存组,根据每个组的设置,决定从哪些 chunk 中提取模块到该组中。</li><li>将选出的模块移动到该缓存组的 chunk 中。</li><li>更新原 chunks 中对这些模块的引用,指向新的 chunk。</li><li>为新生成的 chunk 配置加载规则,在页面加载时请求该 chunk。</li><li>最终页面上加载的不是许多小的重复 chunk,而是一些更大的共用 chunk。</li></ol><p>所以,SplitChunksPlugin 的原理是通过分析模块关系,提取公共模块到更大的 chunk 中,减小重复模块的资源请求次数,提高缓存利用效率,优化页面加载性能。这是它实现代码拆分的核心原理。</p></details><p>2023-04-14 11:48:41</p>`,107),u=[d];function D(y,C,F,h,m,k){return o(),l("div",null,u)}const b=n(r,[["render",D]]);export{g as __pageData,b as default};
