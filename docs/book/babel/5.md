---
title: æ’å…¥å‡½æ•°è°ƒç”¨å‚æ•°
---

å­¦ä¹ å®Œäº† babel çš„ç¼–è¯‘æµç¨‹ã€ASTã€api ä¹‹åï¼Œæˆ‘ä»¬å·²ç»å¯ä»¥åšä¸€äº›æœ‰è¶£çš„äº‹æƒ…äº†ã€‚



## éœ€æ±‚æè¿°

æˆ‘ä»¬å…ˆåšä¸€ä¸ªç®€å•çš„åŠŸèƒ½ç»ƒç»ƒæ‰‹ï¼š

> æˆ‘ä»¬ç»å¸¸ä¼šæ‰“å°ä¸€äº›æ—¥å¿—æ¥è¾…åŠ©è°ƒè¯•ï¼Œä½†æ˜¯æœ‰çš„æ—¶å€™ä¼šä¸çŸ¥é“æ—¥å¿—æ˜¯åœ¨å“ªä¸ªåœ°æ–¹æ‰“å°çš„ã€‚å¸Œæœ›é€šè¿‡ babel èƒ½å¤Ÿè‡ªåŠ¨åœ¨ console.log ç­‰ api ä¸­æ’å…¥æ–‡ä»¶åå’Œè¡Œåˆ—å·çš„å‚æ•°ï¼Œæ–¹ä¾¿å®šä½åˆ°ä»£ç ã€‚



### å®ç°æ€è·¯åˆ†æ

éœ€è¦åšçš„æ˜¯åœ¨éå† AST çš„æ—¶å€™å¯¹ console.logã€console.info ç­‰ api è‡ªåŠ¨æ’å…¥ä¸€äº›å‚æ•°ï¼Œä¹Ÿå°±æ˜¯è¦é€šè¿‡ `visitor` æŒ‡å®šå¯¹å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼ `CallExpression`ï¼ˆè¿™ä¸ªå¯ä»¥é€šè¿‡ [astexplorer.net](https://astexplorer.net/) æ¥æŸ¥çœ‹ï¼‰ åšä¸€äº›å¤„ç†ã€‚CallExpression èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå±æ€§ï¼Œ`callee` å’Œ `arguments`ï¼Œåˆ†åˆ«å¯¹åº”è°ƒç”¨çš„å‡½æ•°åå’Œå‚æ•°ï¼Œ æ‰€ä»¥æˆ‘ä»¬è¦åˆ¤æ–­å½“ callee æ˜¯ console.xx æ—¶ï¼Œåœ¨ arguments çš„æ•°ç»„ä¸­ä¸­æ’å…¥ä¸€ä¸ª AST èŠ‚ç‚¹ã€‚

![CallExpression](./imgs/5-2.webp)

æ•´ä½“æµç¨‹

![Babelè½¬è¯‘æµç¨‹](./imgs/5-1.webp)





### ä»£ç å®ç°

é¦–å…ˆæŠŠ parseã€transformã€generate çš„æ¡†æ¶æ­å¥½ï¼š

```js
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;
const types = require('@babel/types')

const sourceCode = `console.log(1);`;

const ast = parser.parse(sourceCode, {
  sourceType: 'unambiguous'
});

traverse(ast, {
  CallExpression(path, state) {

  }
});

const { code, map } = generate(ast);
console.log(code);
```

::: tip

å› ä¸º `@babel/parser` ç­‰åŒ…éƒ½æ˜¯é€šè¿‡ es module å¯¼å‡ºçš„ï¼Œæ‰€ä»¥é€šè¿‡ commonjs çš„æ–¹å¼å¼•å…¥æœ‰çš„æ—¶å€™è¦å– default å±æ€§ã€‚

:::

`parser` éœ€è¦æŒ‡å®šä»£ç æ˜¯ä¸æ˜¯åŒ…å« importã€export ç­‰ï¼Œéœ€è¦è®¾ç½® `moduleType` ä¸º module æˆ–è€… scriptï¼Œæˆ‘ä»¬å¹²è„†è®¾ç½®ä¸º unambiguousï¼Œè®©å®ƒæ ¹æ®å†…å®¹æ˜¯å¦åŒ…å« importã€export æ¥è‡ªåŠ¨è®¾ç½® moduleTypeã€‚

æ­å¥½æ¡†æ¶ä¹‹åï¼Œæˆ‘ä»¬å…ˆè®¾è®¡ä¸€ä¸‹è¦è½¬æ¢çš„ä»£ç ï¼š

```js
const sourceCode = `
  console.log(1);

  function func() {
    console.info(2);
  }

  export default class Clazz {
    say() {
      console.debug(3);
    }

    return() {
      return <div>{console.error(4)}</div>
    }
  }
`
```

ä»£ç æ²¡å•¥å…·ä½“å«ä¹‰ï¼Œä¸»è¦æ˜¯ç”¨äºæµ‹è¯•åŠŸèƒ½ã€‚

è¿™é‡Œç”¨åˆ°äº† jsx çš„è¯­æ³•ï¼Œæ‰€ä»¥ parser è¦å¼€å¯ jsx çš„ `plugin`ã€‚

æˆ‘ä»¬æŒ‰ç…§å‰é¢åˆ†æçš„æ€è·¯æ¥å†™ä¸€ä¸‹ä»£ç ï¼š

```js
const ast = parser.parse(sourceCode, {
  sourceType: 'unambiguous',
  plugins: ['jsx']
})

traverse(ast, {
  CallExpression(path, state) {
    if (type.isMemberExpression(path.node.callee)
        && path.node.callee.object.name === 'console'
        && ['log', 'error', 'info', 'debug'].includes(path.node.callee.property.name)
    ) {
      const { line, column } = path.node.loc.start
      path.node.arguments.unshift(types.stringLiteral(`filename: (${line}, ${column})`))
    }
  }
})
```

å½“æ˜¯ `console.xxx` çš„ AST æ—¶ï¼Œåœ¨å‚æ•°ä¸­æ’å…¥**æ–‡ä»¶å**å’Œ**è¡Œåˆ—å·**ï¼Œè¡Œåˆ—å·ä» AST çš„å…¬å…±å±æ€§ `loc` ä¸Šå–ã€‚

è¾“å‡ºçš„ä»£ç ç¬¦åˆé¢„æœŸï¼š

```js
console.log("filename: (2, 2)", 1);
function func() {
  console.info("filename: (5, 4)", 2);
}
export default class Clazz {
  say() {
    console.debug("filename: (10, 6)", 3);
  }
  return() {
    return <div>{console.error("filename: (14, 19)", 4)}</div>;
  }
}
```

::: details ä½¿ç”¨TypeScriptå®ç°

å…ˆå®‰è£…ä¾èµ–ï¼š

```bash
pnpm i -D typescript tsx
pnpm i -D @babel/core @babel/parser @babel/template @babel/types @babel/generator

# å®‰è£…ç±»å‹
pnpm i -D @types/node @types/babel__core @types/babel__generator @types/babel__template @types/babel__traverse
```

ä»£ç å®ç°ï¼š`main.ts`

```typescript
import { parse } from '@babel/parser'
import traverse from '@babel/traverse'
import generate from '@babel/generator'
import { Identifier, isMemberExpression, stringLiteral } from '@babel/types'

const sourceCode = `
  console.log(1);

  function func() {
    console.info(2);
  }

  export default class Clazz {
    say() {
      console.debug(3);
    }

    return() {
      return <div>{console.error(4)}</div>
    }
  }
`

const ast = parse(sourceCode, {
  sourceType: 'unambiguous',
  plugins: ['jsx']
})

traverse(ast, {
  CallExpression(path, state) {
    if (
      isMemberExpression(path.node.callee)
      // ğŸ’¡è½¬æ¢ä¸º Identifer ç±»å‹
      && (path.node.callee.object as Identifier).name === 'console'
      && ['log', 'info', 'error', 'debug'].includes((path.node.callee.property as Identifier).name)
    ) {
      const { line, column } = path.node.loc!.start
      path.node.arguments.unshift(stringLiteral(`filename: (${line}, ${column})`))
    }
  }
})

const { code, map } = generate(ast)

console.log(code)
```



è¿è¡Œå‘½ä»¤ `npx tsx main.ts` æ‰“å°ç»“æœ

:::





ğŸ’¡ç°åœ¨åˆ¤æ–­æ¡ä»¶æ¯”è¾ƒå¤æ‚ï¼Œè¦å…ˆåˆ¤æ–­ `path.node.callee` çš„ç±»å‹ï¼Œç„¶åä¸€å±‚å±‚å–å±æ€§æ¥åˆ¤æ–­ï¼Œå…¶å®æˆ‘ä»¬å¯ä»¥ç”¨ `generator` æ¨¡å—æ¥ç®€åŒ–

```js
const targetCallName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`)

traverse(ast, {
  CallExpression(path, state) {
    const calleeName = generate(path.node.callee).code
    if (targetCallName.includes(calleeName)) {
      const { line, column } = path.node.loc.start
      path.node.arguments.unshift(types.stringLiteral(`filename: (${line}, ${column})`))
    }
  }
})
```

ä»£ç ç¬é—´ç²¾ç®€äº†å¾ˆå¤šï¼Œè¿˜å¯ä»¥è°ƒç”¨ `path.get('callee').toString()`ï¼Œä¸€æ ·çš„æ•ˆæœã€‚

::: details ä½¿ç”¨TypeScriptå®ç°

```typescript
import { parse } from '@babel/parser'
import traverse from '@babel/traverse'
import generate from '@babel/generator'
import { stringLiteral } from '@babel/types'

const sourceCode = `
  console.log(1);

  function func() {
    console.info(2);
  }

  export default class Clazz {
    say() {
      console.debug(3);
    }

    return() {
      return <div>{console.error(4)}</div>
    }
  }
`

const ast = parse(sourceCode, {
  sourceType: 'unambiguous',
  plugins: ['jsx']
})


const targetCalleeName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`);
traverse(ast, {
  CallExpression(path, state) {
    const calleeName = generate(path.node.callee).code
    if (targetCalleeName.includes(calleeName)) {
      const { line, column } = path.node.loc!.start
      path.node.arguments.unshift(stringLiteral(`filename: (${line}, ${column})`))
    }
  }
})

const { code, map } = generate(ast)

console.log(code)
```

:::



## éœ€æ±‚å˜æ›´

åæ¥æˆ‘ä»¬è§‰å¾—åœ¨åŒä¸€è¡Œæ‰“å°ä¼šå½±å“åŸæœ¬çš„å‚æ•°çš„å±•ç¤ºï¼Œæ‰€ä»¥æƒ³æ”¹ä¸ºåœ¨ console.xx **èŠ‚ç‚¹ä¹‹å‰æ‰“å°**çš„æ–¹å¼



### æ€è·¯åˆ†æ

è¿™ä¸ªéœ€æ±‚çš„æ”¹åŠ¨åªæ˜¯ä»å‚æ•°ä¸­æ’å…¥å˜æˆäº†åœ¨å½“å‰ console.xx çš„ASTä¹‹å‰æ’å…¥ä¸€ä¸ª console.log çš„ ASTï¼Œæ•´ä½“æµç¨‹è¿˜æ˜¯ä¸€æ ·ã€‚åˆ›å»ºè¿™ç§è¾ƒå¤æ‚çš„ ASTï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `@babel/template`åŒ…ã€‚

ğŸš¨è¿™é‡Œæœ‰ä¸¤ä¸ªæ³¨æ„çš„ç‚¹ï¼š

- JSX ä¸­çš„ console ä»£ç ä¸èƒ½ç®€å•çš„åœ¨å‰é¢æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œè¦æŠŠæ•´ä½“æ›¿æ¢æˆä¸€ä¸ªæ•°ç»„è¡¨è¾¾å¼ï¼Œå› ä¸º JSX ä¸­åªæ”¯æŒå†™å•ä¸ªè¡¨è¾¾å¼ã€‚

ä¹Ÿå°±æ˜¯

```jsx
<div>{console.log(111)}</div>
```

è¦æ›¿æ¢æˆæ•°ç»„çš„å½¢å¼

```jsx
<div>{[console.log('filename.js(11,22)'), console.log(111)]}</div>
```

- ç”¨æ–°çš„èŠ‚ç‚¹æ›¿æ¢äº†æ—§çš„èŠ‚ç‚¹ä¹‹åï¼Œ**babel traverse ä¼šç»§ç»­éå†æ–°èŠ‚ç‚¹ï¼Œè¿™æ˜¯æ²¡å¿…è¦çš„ï¼Œæ‰€ä»¥è¦è·³è¿‡æ–°ç”Ÿæˆçš„èŠ‚ç‚¹çš„å¤„ç†**ã€‚



### ä»£ç å®ç°

æ’å…¥ AST å¯ä»¥ä½¿ç”¨ `path.insertBefore` çš„ apiï¼Œ è€Œæ›¿æ¢æ•´ä½“èŠ‚ç‚¹ç”¨ `path.replaceWith`ï¼Œ åˆ¤æ–­æ˜¯ insertBefore è¿˜æ˜¯ replaceWith è¦çœ‹å½“å‰èŠ‚ç‚¹æ˜¯å¦åœ¨ JSXElement ä¹‹ä¸‹ï¼Œæ‰€ä»¥è¦ç”¨`path.findParent` æ–¹æ³•é¡ºç€ path æŸ¥æ‰¾æ˜¯å¦æœ‰ JSXElement èŠ‚ç‚¹ã€‚replace çš„æ–°èŠ‚ç‚¹è¦è°ƒç”¨ `path.skip` è·³è¿‡åç»­éå†ã€‚

```js
if (path.findParent(path => path.isJSXElement())) {
  path.replaceWith(types.arrayExpression([newNode, path.node]))
  path.skip();// è·³è¿‡å­èŠ‚ç‚¹å¤„ç†
} else {
  path.insertBefore(newNode);
}
```

è¦è·³è¿‡æ–°çš„èŠ‚ç‚¹çš„å¤„ç†ï¼Œå°±éœ€è¦åœ¨èŠ‚ç‚¹ä¸ŠåŠ ä¸€ä¸ªæ ‡è®°ï¼Œå¦‚æœæœ‰è¿™ä¸ªæ ‡è®°çš„å°±è·³è¿‡ã€‚

æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š

```js
const targetCalleeName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`);
traverse(ast, {
  CallExpression(path, state) {
    if (path.node.isNew) {
      return
    }

    const calleeName = generate(path.node.callee).code
    if (targetCalleeName.includes(calleeName)) {
      const { line, column } = path.node.loc!.start;
      const newNode = template.expression(`console.log("filename: (${line}, ${column})")`)();
      newNode.isNew = true

      if (path.findParent(path => path.isJSXElement())) {
        path.replaceWith(types.arrayExpression([newNode, path.node]))
        path.skip() // è·³è¿‡å­èŠ‚ç‚¹å¤„ç†
      } else {
        path.insertBefore(newNode)
      }
    }
  }
})
```

::: details ä½¿ç”¨TypeScriptå®ç°

```typescript
import { parse } from '@babel/parser'
import traverse from '@babel/traverse'
import generate from '@babel/generator'
import { arrayExpression } from '@babel/types'
import { expression } from '@babel/template'

const sourceCode = `
  console.log(1);

  function func() {
    console.info(2);
  }

  export default class Clazz {
    say() {
      console.debug(3);
    }

    return() {
      return <div>{console.error(4)}</div>
    }
  }
`

const ast = parse(sourceCode, {
  sourceType: 'unambiguous',
  plugins: ['jsx']
})

// ç»™ CallExpression æ¥å£æ‰©å±•ä¸€ä¸ªå±æ€§
interface CallExpression {
  isNew?: boolean
}

const targetCalleeName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`);
traverse(ast, {
  CallExpression(path, state) {
    // è½¬æ¢æˆ CallExpression ç±»å‹
    if ((path.node as CallExpression).isNew) {
      return
    }

    const calleeName = generate(path.node.callee).code
    if (targetCalleeName.includes(calleeName)) {
      const { line, column } = path.node.loc!.start;
      const newNode = expression(`console.log("filename: (${line}, ${column})")`)();
      (newNode as CallExpression).isNew = true
      // path.node.arguments.unshift(stringLiteral(`filename: (${line}, ${column})`))

      if (path.findParent(path => path.isJSXElement())) {
        path.replaceWith(arrayExpression([newNode, path.node]))
        path.skip() // è·³è¿‡å­èŠ‚ç‚¹å¤„ç†
      } else {
        path.insertBefore(newNode)
      }
    }
  }
})

const { code, map } = generate(ast)

console.log(code)
```

:::



## æ”¹é€ æˆbabelæ’ä»¶

ä¸Šé¢å®Œæˆçš„åŠŸèƒ½æƒ³è¦å¤ç”¨å°±å¾—å°è£…æˆæ’ä»¶çš„å½¢å¼ï¼Œbabel æ”¯æŒ `transform` æ’ä»¶ï¼Œå½¢å¼æ˜¯å‡½æ•°è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œå¯¹è±¡æœ‰ `visitor` å±æ€§ã€‚

```js
module.exports = function(api, options) {
  return {
    visitor: {
      Identifier(path, state) {},
    }
  }
}
```

- ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ‹¿åˆ° `types`ã€`template` ç­‰å¸¸ç”¨åŒ…çš„ `api`ï¼Œä¸éœ€è¦å•ç‹¬å¼•å…¥è¿™äº›åŒ…ã€‚
- ğŸ“š **ä½œä¸ºæ’ä»¶ç”¨çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦è‡ªå·±è°ƒç”¨ parseã€traverseã€generateï¼Œåªéœ€è¦æä¾›ä¸€ä¸ª visitor å‡½æ•°ï¼Œåœ¨è¿™ä¸ªå‡½æ•°å†…å®Œæˆè½¬æ¢åŠŸèƒ½ã€‚**
- `state` ä¸­å¯ä»¥æ‹¿åˆ°ç”¨æˆ·é…ç½®ä¿¡æ¯ options å’Œ file ä¿¡æ¯ï¼Œfilename å°±å¯ä»¥é€šè¿‡ `state.filename` æ¥å–ã€‚

ä¸Šé¢çš„ä»£ç å¾ˆå®¹æ˜“å¯ä»¥æ”¹é€ æˆæ’ä»¶ï¼š

```js
const targetCalleeName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`)

module.exports = function({ types, template }) {
  return {
    visitor: {
      CallExpression(path, state) {
        if (path.node.isNew) {
          return
        }
        
        const calleeName = generate(path.node.callee).code
        if (targetCalleeName.includes(calleeName)) {
          const { line, column } = path.node.loc.start
          const newNode = template.expression(`console.log("${state.filename || 'unknown filename'}: (${line}, ${column})"`)();
          newNode.isNew = true
          
          if (path.findParent(path => path.isJSXElement())) {
            path.replaceWith(types.arrayExpression([newNode, path.node]))
            path.skip()
          } else {
            path.insertBefore(newNode)
          }
        }
      }
    }
  }
}
```

ç„¶åé€šè¿‡ `@babel/core` çš„ `transformSync` æ–¹æ³•æ¥è°ƒç”¨

```js
const { transformFileSync } = require('@babel/core')
const insertParametersPlugin = require('./pluin/parameters-insert-plugin')
const path = require('path')

const { code } = transformFileSync(path.join(__dirname, './sourceCode.js'), {
  plugins: [parametersInsertPlugin],
  parserOpts: {
    sourceType: 'unambiguous',
    plugins: ['jsx']
  }
})

console.log(code)
```

è¿™æ ·æˆ‘ä»¬æˆåŠŸå°±æŠŠå‰é¢è°ƒç”¨ parseã€traverseã€generate çš„ä»£ç æ”¹é€ æˆäº† babel æ’ä»¶çš„å½¢å¼ï¼Œåªéœ€è¦æä¾›ä¸€ä¸ªè½¬æ¢å‡½æ•°ï¼Œtraverse çš„è¿‡ç¨‹ä¸­ä¼šè‡ªåŠ¨è°ƒç”¨ã€‚

::: details ä½¿ç”¨TypeScriptå®ç°

`parameters-insert-plugin.ts`:

```typescript
import * as t from '@babel/types';
import { NodePath } from '@babel/traverse'
import generate from '@babel/generator'
import * as BabelTemplate from '@babel/template'

// æ‰©å±• CallExpression å±æ€§
interface CallExpression {
  isNew?: boolean
}

const targetCalleeName = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`);

function parametersInsertPlugin({ types, template }: {types: typeof t; template: typeof BabelTemplate}) {
  return {
    visitor: {
      // ğŸš¨ è¿™é‡Œçš„stateç±»å‹å¯èƒ½å­˜åœ¨é”™è¯¯ éœ€è¦è¿›ä¸€æ­¥éªŒè¯
      CallExpression(path: NodePath<t.CallExpression>, state: t.Node) {
        if ((path.node as CallExpression).isNew) {
          return
        }
        const calleeName = generate(path.node.callee).code
        if (targetCalleeName.includes(calleeName)) {
          const { line, column } = path.node.loc!.start;
          // ğŸš¨ ä½¿ç”¨ä¸‹é¢è¿™è¡Œ ä¼šæŠ¥é”™ éœ€è¦è¿›ä¸€æ­¥å­¦ä¹ è¿™ä¸€å—
          // const newNode = template.expression(`console.log("${state.filename || 'unknown filename'}: (${line}, ${column})"`)();
          const newNode = template.expression(`console.log("filename: (${line}, ${column})")`)();
          (newNode as CallExpression).isNew = true
    
          if (path.findParent(path => path.isJSXElement())) {
            path.replaceWith(types.arrayExpression([newNode, path.node]))
            path.skip() // è·³è¿‡å­èŠ‚ç‚¹å¤„ç†
          } else {
            path.insertBefore(newNode)
          }
        }
      }
    }
  }
}

export default parametersInsertPlugin
```

`sourceCode.js`:

```js
console.log(1);

function func() {
  console.info(2);
}

export default class Clazz {
  say() {
    console.debug(3);
  }

  return() {
    return <div>{console.error(4)}</div>
  }
}
```

`main.ts`:

```typescript
import { transformFileSync } from '@babel/core'
import parametersInsertPlugin from './parameters-insert-plugin'
import path from 'node:path'

const { code } = transformFileSync(path.join(__dirname, './sourceCode.js'), {
  plugins: [parametersInsertPlugin],
  parserOpts: {
    sourceType: 'unambiguous',
    plugins: ['jsx']
  }
})!


console.log(code)
```

è¿è¡Œ `npx tsx main.ts`

:::



## æ€»ç»“

è¿™ä¸€èŠ‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåœ¨ console.xxx ä¸­æ’å…¥å‚æ•°çš„å®æˆ˜æ¡ˆä¾‹ç»ƒä¹ äº†ä¸‹ babel çš„ apiã€‚

é¦–å…ˆé€šè¿‡ `@babel/parser`ã€`@babel/traverse`ã€`@babel/generator` æ¥ç»„ç»‡ç¼–è¯‘æµç¨‹ï¼Œé€šè¿‡`@babel/types` åˆ›å»ºASTï¼Œé€šè¿‡ path çš„å„ç§ api å¯¹ AST è¿›è¡Œæ“ä½œã€‚

åæ¥éœ€æ±‚æ”¹ä¸ºåœ¨å‰é¢æ’å…¥ console.xxx çš„æ–¹å¼ï¼Œæˆ‘ä»¬å¼•å…¥äº† `@babel/template` åŒ…ï¼Œé€šè¿‡ path.replaceWith å’Œ path.insertBefore æ¥æ“ä½œ ASTï¼Œéœ€è¦é€šè¿‡ path.findParent æ¥åˆ¤æ–­ AST çš„çˆ¶å…ƒç´ æ˜¯å¦åŒ…å« JSXElement ç±»å‹çš„ ASTã€‚å­èŠ‚ç‚¹çš„ AST è¦ç”¨ path.skip è·³è¿‡éå†ï¼Œè€Œä¸”è¦å¯¹æ–°çš„ AST åšæ ‡è®°ï¼Œè·³è¿‡å¯¹æ–°ç”Ÿæˆçš„èŠ‚ç‚¹çš„å¤„ç†ã€‚

ä¹‹åæˆ‘ä»¬æŠŠå®ƒæ”¹é€ æˆäº† babel æ’ä»¶ï¼Œæ˜¯ä¸€ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ªå¯¹è±¡çš„æ ¼å¼ï¼Œå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ‹¿åˆ°å„ç§ babel å¸¸ç”¨åŒ…çš„ apiï¼Œæ¯”å¦‚ typesã€templateã€‚ æ’ä»¶ä¸éœ€è¦è°ƒç”¨ parseã€traverseã€generate ç­‰ apiï¼Œåªéœ€è¦æä¾› visitor å‡½æ•°ã€‚æœ€åæˆ‘ä»¬é€šè¿‡ @babel/core çš„ api ä½¿ç”¨äº†ä¸‹è¿™ä¸ªæ’ä»¶ã€‚

å­¦å®Œè¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬å¯¹å‰ 3 èŠ‚å­¦ä¹ çš„ç¼–è¯‘æµç¨‹ã€ASTã€api éƒ½åšäº†ä¸€äº›å®è·µï¼Œæœ‰äº†æ›´å…·ä½“çš„ç†è§£ã€‚



æºç åœ°å€ï¼š

- [exercise-parameters-insert - @github](https://github.com/QuarkGluonPlasma/babel-plugin-exercize/tree/master/exercize-parameters-insert)



2023å¹´03æœˆ24æ—¥16:51:51

