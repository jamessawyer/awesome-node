---
JS Parserå†å²
---

å‰é¢æˆ‘ä»¬å­¦ä¹ äº† babel çš„ parser å’Œ ASTï¼Œbabel çš„ parser æ˜¯åŸºäº `acorn` æ‰©å±•è€Œæ¥çš„ï¼Œè€Œ acorn ä¹Ÿä¸æ˜¯æœ€æ—©çš„ js parserï¼Œjs parser çš„å†å²æ˜¯æ€æ ·çš„ï¼Ÿ å„ç§ parser ä¹‹é—´çš„å…³ç³»æ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿè¿™èŠ‚æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ã€‚

## SpiderMonkey å’Œ estree æ ‡å‡†

åœ¨ nodejs å‡ºç°ä¹‹åï¼Œå‰ç«¯å¯ä»¥ç”¨ nodejs æ¥åšä¸€äº›å·¥ç¨‹åŒ–çš„äº‹æƒ…ï¼Œä¹Ÿå°±æœ‰äº†å¯¹ js parser çš„éœ€æ±‚ï¼Œå½“æ—¶ Mozilla åœ¨ MDN ä¸Šå…¬å¸ƒäº† SpiderMonkeyï¼ˆc++ å†™çš„ js å¼•æ“ï¼‰çš„ parser api å’Œ AST æ ‡å‡†ï¼Œæ‰€ä»¥å½“æ—¶æœ€æ—©çš„ JS parser ---- [esprima](https://github.com/jquery/esprima) å°±æ˜¯åŸºäº SpiderMonkey çš„ AST æ ‡å‡†æ¥å®ç°çš„ï¼Œåæ¥å½¢æˆäº† [estree æ ‡å‡†](https://github.com/estree/estree)ã€‚ å½“æ—¶å¾ˆå¤šçš„å‰ç«¯é¢†åŸŸçš„å·¥å…·éƒ½åŸºäº esprimaã€‚

ä½†æ˜¯åˆ°äº† 2015 å¹´ä¹‹åï¼Œes æ ‡å‡†ä¸€å¹´ä¸€ä¸ªç‰ˆæœ¬ï¼Œè€Œ esprima çš„æ›´æ–°é€Ÿåº¦è·Ÿä¸ä¸Šï¼Œå®ƒè·Ÿä¸ä¸Šä¹Ÿå°±å¯¼è‡´äº†ä¾èµ–å®ƒçš„ä¸€ç³»åˆ—å·¥å…·éƒ½è·Ÿä¸ä¸Šï¼Œæ‰€ä»¥ eslint å°± fork äº†ä¸€ä»½ esprimaï¼Œåšäº†ä¸€äº›æ‰©å±•ï¼Œæ¥è‡ªå·±å®ç°æ–°è¯­æ³•çš„ parseï¼Œè¿™å°±æ˜¯ espreeï¼Œå®ƒä¾ç„¶æ˜¯ estree æ ‡å‡†çš„ã€‚

## acorn

åé¢å‡ºç°äº† acornï¼Œä¹Ÿæ˜¯ `estree` æ ‡å‡†çš„å®ç°ï¼Œä½†æ˜¯ä»–çš„é€Ÿåº¦æ¯” esprima å¿«ï¼Œè€Œä¸”æ”¯æŒæ’ä»¶ï¼Œå¯ä»¥é€šè¿‡æ’ä»¶æ‰©å±•è¯­æ³•æ”¯æŒã€‚æ­£æ˜¯é€Ÿåº¦å¿«åŠ ä¸Šæ”¯æŒæ’ä»¶è®©å¾ˆå¤šå·¥å…·éƒ½è½¬è€Œä½¿ç”¨ acornã€‚

eslint çš„ parser ---- espree æœ¬æ¥æ˜¯ fork è‡ª esprimaï¼Œä½†åæ¥ espree 2.0 åŸºäº acorn é‡æ–°å®ç°äº†ï¼Œä¹Ÿä½¿ç”¨ acorn çš„æ’ä»¶æœºåˆ¶æ¥æ‰©å±•è¯­æ³•ã€‚

`babel parser`(babylon) ä¹Ÿæ˜¯åŸºäº acornï¼Œå¹¶ä¸”å¯¹ AST èŠ‚ç‚¹å’Œå±æ€§éƒ½åšäº†æ‰©å±•ï¼Œä¹Ÿæä¾›äº†ä¸€äº›æ”¯æŒ typescriptã€jsxã€flow çš„**æ’ä»¶**ï¼ˆå°±æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨ @babel/parser çš„ plugins é‡Œé¢æŒ‡å®šçš„é‚£äº›ï¼‰ã€‚



## JS Parserä¹‹é—´çš„å…³ç³»

![JS Parsers](./imgs/6-1.webp)

å®ƒä»¬çš„å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼Œestree æ ‡å‡†æ˜¯åŸºäº SpiderMonkey çš„ AST æ ‡å‡†æ‰©å±•çš„ï¼Œå®ƒçš„å®ç°æœ‰ esprimaã€acorn ç­‰ï¼Œç°åœ¨ espreeã€babel parser éƒ½æ˜¯åŸºäºacornåšçš„æ‰©å±•ï¼Œå› ä¸º acorn æä¾›äº†æ’ä»¶æœºåˆ¶ã€‚

å½“ç„¶ä¹Ÿä¸æ˜¯æ‰€æœ‰çš„ js parser éƒ½æ˜¯ estree æ ‡å‡†çš„ï¼Œæ¯”å¦‚ terserã€typescript ç­‰éƒ½æœ‰è‡ªå·±çš„ AST æ ‡å‡†ã€‚





## babel parserå¯¹estree ASTçš„æ‰©å±•

`babel` åŸºäº **acorn æ’ä»¶**å¯¹ estree AST åšäº†å¦‚ä¸‹æ‰©å±•:

1. æŠŠ `Literal` æ›¿æ¢æˆäº† `StringLiteralã€NumericLiteralã€ BigIntLiteralã€ BooleanLiteralã€ NullLiteralã€ RegExpLiteral`
2. æŠŠ `Property` æ›¿æ¢æˆäº† `ObjectProperty` å’Œ `ObjectMethod`
3. æŠŠ `MethodDefinition` æ›¿æ¢æˆäº† `ClassMethod`
4. Program å’Œ BlockStatement æ”¯æŒäº† `directives` å±æ€§ï¼Œä¹Ÿå°±æ˜¯ 'use strict' ç­‰æŒ‡ä»¤çš„è§£æï¼Œå¯¹åº”çš„ ast æ˜¯ Directive å’Œ DirectiveLiteral
5. ChainExpression æ›¿æ¢ä¸ºäº† ObjectMemberExpression å’Œ OptionalCallExpression
6. ImportExpression æ›¿æ¢ä¸ºäº† CallExpression å¹¶ä¸” callee å±æ€§è®¾ç½®ä¸º Import

è¿™äº›å¯ä»¥åœ¨ [babel parser çš„æ–‡æ¡£](https://babeljs.io/docs/en/babel-parser#output)é‡Œçœ‹åˆ°ã€‚



## acornæ’ä»¶

babel parser åŸºäº acorn æ‰©å±•äº†ä¸€äº›è¯­æ³•ï¼Œé‚£å®ƒæ˜¯æ€ä¹ˆæ‰©å±•çš„å‘¢ï¼Ÿ æˆ‘ä»¬å†™ä¸€ä¸ª acorn æ’ä»¶æ¥æ„Ÿå—ä¸€ä¸‹ã€‚

acorn ä¸»è¦æ˜¯ä¸€ä¸ª `Parser` ç±»ï¼Œä¸åŒçš„æ–¹æ³•å®ç°äº†ä¸åŒçš„é€»è¾‘ï¼Œæ’ä»¶æ‰©å±•å°±æ˜¯**ç»§æ‰¿**è¿™ä¸ª Parserï¼Œé‡å†™ä¸€äº›æ–¹æ³•ã€‚

acorn çš„ api å¦‚ä¸‹ï¼Œå…¶ä¸­ `acorn-jsx`ã€`acorn-bigint` å°±æ˜¯ acorn æ’ä»¶

```js
/**
 * @type {import('acorn')}
 */
const { Parser } = require('acorn')

const MyParser = Parser.extend(
  require('acorn-jsx')(),
  require('acorn-bigint')
)

console.log(MyParser.parse('// Some bigint + JSX code'))
```

::: details å®‰è£…ä¾èµ–

```bash
pnpm i -D acorn acorn-jsx acorn-bigint
```

:::

**æ’ä»¶æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ¥æ”¶ä¹‹å‰çš„ Parserï¼Œè¿”å›æ‰©å±•ä»¥åçš„ Parser**

```js
module.exports = function noisyReadToken(Parser) {
  return class extends Parser {
    readToken(code) {
      console.log("Reading a token!")
      super.readToken(code)
    }
  }
}
```

æ¥ä¸‹æ¥æˆ‘ä»¬å†™ä¸€ä¸ªacornæ’ä»¶ï¼š**ç»™ javascript ä¸€ä¸ªå…³é”®å­— `guang`ï¼Œå¯ä»¥ä½œä¸º `statement` å•ç‹¬ä½¿ç”¨**

ğŸ’¡æˆ‘ä»¬çŸ¥é“ parse çš„è¿‡ç¨‹å…¶å®å°±æ˜¯`åˆ†è¯` + `ç»„è£… AST`è¿™ä¸¤æ­¥ï¼ˆä¸€èˆ¬å«è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æï¼‰ï¼Œæˆ‘ä»¬åªè¦å®ç°è¿™ä¸¤æ­¥å°±å¯ä»¥äº†ã€‚



### åˆ†è¯ï¼ˆè¯æ³•åˆ†æï¼‰

æˆ‘ä»¬æ˜¯æƒ³å¢åŠ ä¸€ä¸ª`å…³é”®å­—`ï¼Œacorn æœ‰ `keywords` å±æ€§ï¼Œæ˜¯ä¸€ä¸ª**æ­£åˆ™è¡¨è¾¾å¼**ï¼Œç”¨æ¥åšå…³é”®å­—æ‹†åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬é‡å†™ keywords å±æ€§å°±å¯ä»¥ã€‚å¹¶ä¸”è¿˜è¦ä¸ºæ–°çš„å…³é”®å­—æ³¨å†Œä¸€ä¸ª `token` ç±»å‹ã€‚

acorn Parser çš„å…¥å£æ–¹æ³•æ˜¯ parseï¼Œæˆ‘ä»¬è¦åœ¨ parse æ–¹æ³•é‡Œé¢è®¾ç½® keywordsã€‚

```js {3}
parse(program) {
    var newKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this const class extends export import super";
    newKeywords += " guang";// å¢åŠ ä¸€ä¸ªå…³é”®å­—
    this.keywords = new RegExp("^(?:" + newKeywords.replace(/ /g, "|") + ")$")

    return(super.parse(program));
}
```

ç„¶åæ³¨å†Œä¸€ä¸ªæ–°çš„ token ç±»å‹æ¥æ ‡è¯†å®ƒ

```js
Parser.acorn.keywordTypes['guang'] = new TokenType('guang', { keyword: 'guang' })
```

è¿™æ · acorn å°±ä¼šåœ¨ parse çš„æ—¶å€™åˆ†å‡º `guang` è¿™ä¸ªå…³é”®å­—



### ç»„è£…ASTï¼ˆè¯­æ³•åˆ†æï¼‰

å…‰åˆ†å‡º token æ˜¯æ²¡æ„ä¹‰çš„ï¼Œè¦ç»„è£…åˆ° AST ä¸­ã€‚

acorn åœ¨ parse åˆ°ä¸åŒç±»å‹çš„èŠ‚ç‚¹ä¼šè°ƒç”¨ä¸åŒçš„ parseXxx æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨ statement é‡Œé¢ç”¨ï¼Œé‚£ä¹ˆå°±è¦é‡å†™ `parseStatement` æ–¹æ³•ï¼Œåœ¨é‡Œé¢ç»„è£…æ–°çš„ statement èŠ‚ç‚¹ã€‚

```js
parseStatement(context, topLevel, exports) {
  var tokenType = this.type;

  if (tokenType == Parser.acorn.keywordTypes["guang"]) {
    var node = this.startNode();
    this.next();
    return this.finishNode({value: 'guang'},'GuangStatement');
  }
  else {
    return(super.parseStatement(context, topLevel, exports));
  }
}
```

- `this.type` æ˜¯å½“å‰å¤„ç†åˆ°çš„ token çš„ç±»å‹ï¼Œ `this.next` æ˜¯æ¶ˆè´¹è¿™ä¸ª tokenï¼Œæˆ‘ä»¬è¯†åˆ«å‡º token çš„ç±»å‹ä¸º `guang` çš„æ—¶å€™ï¼Œå°±ç»„è£…æˆä¸€ä¸ª ASTã€‚
- é€šè¿‡ `this.startNode()` åˆ›å»ºä¸€ä¸ªæ–°çš„ASTèŠ‚ç‚¹ï¼Œç„¶å `this.next()` æ¶ˆè´¹æ‰è¿™ä¸ª tokenï¼Œä¹‹åè¿”å›æ–°çš„ AST èŠ‚ç‚¹ã€‚
- å¦‚æœä¸æ˜¯æˆ‘ä»¬æ‰©å±•çš„ tokenï¼Œåˆ™è°ƒç”¨çˆ¶ç±»çš„ `parseStatement` å¤„ç†ã€‚
- è¿™æ ·èƒ½æˆåŠŸåˆ†å‡ºtokenï¼Œä½†æ˜¯æœ€å¥½æŠŠå®ƒç‹¬ç«‹æˆä¸€ä¸ªæ–¹æ³•ï¼Œè¿™æ ·å­ç±»å¯ä»¥è¦†ç›–è¿™ä¸ªæ–¹æ³•æ¥å¯¹ parse é€»è¾‘åšä¿®æ”¹ã€‚

```js
parseStatement(context, topLevel, exports) {
  var tokenType = this.type;

  if (tokenType == Parser.acorn.keywordTypes["guang"]) {
    var node = this.startNode();
    return this.parseGuangStatement(node);
  }
  else {
    return(super.parseStatement(context, topLevel, exports));
  }
}

parseGuangStatement(node) {
  this.next();
  return this.finishNode({value: 'guang'}, 'GuangStatement');
}
```

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```js
/**
 * @type {import('acorn')}
 */
const { Parser, TokenType } = require('acorn')


Parser.acorn.keywordTypes['guang'] = new TokenType('guang', {
  keyword: 'guang'
})

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

/**
 * 
 * @param {Parser} Parser 
 */
var guangKeywordPlugin = function(Parser) {
  return class extends Parser {
    parse(program) {
      let newKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this const class extends export import super";
      newKeywords += " guang";
      this.keywords = new RegExp("^(?:" + newKeywords.replace(/ /g, "|") + ")$")
      // this.keywords = wordsRegexp(newKeywords)
      
      // ğŸš¨æ³¨æ„è¿™é‡Œçš„ `return` æ˜¯ä¸€ä¸ªå‡½æ•°
      return(super.parse(program));
    }

    parseStatement(context, topLevel, exports) {
      var startType = this.type

      if (startType == Parser.acorn.keywordTypes['guang']) {
        var node = this.startNode()
        return this.parseGuangState(node)
      } else {
        return(super.parseStatement(context, topLevel, exports))
      }
    }

    parseGuangState(node) {
      this.next()
      return this.finishNode({ value: 'guang' }, 'GuangStatement')
    }
  }
}

const newParser = Parser.extend(guangKeywordPlugin)


var program = 
`
    guang
    const a = 1
`;

// ä¸ºäº†é¿å…è­¦å‘Šï¼Œæ·»åŠ  `{ ecmaVersion: 2020 }` options
// Since Acorn 8.0.0, options.ecmaVersion is required.
// Defaulting to 2020, but this will stop working in the future.
const ast = newParser.parse(program, { ecmaVersion: 2020 })
console.log(ast)
```

æˆ‘ä»¬æ‰§è¡Œä¸‹è¯•ä¸‹æ•ˆæœï¼Œäº§ç”Ÿçš„ASTå¦‚ä¸‹ï¼š

```bash
Node {
  type: 'Program',
  start: 0,
  end: 27,
  body: [
    { value: 'guang', type: 'GuangStatement', end: 10 },
    Node {
      type: 'VariableDeclaration',
      start: 15,
      end: 26,
      declarations: [Array],
      kind: 'const'
    }
  ],
  sourceType: 'script'
}
```

å°±è¿™æ ·æˆ‘ä»¬å®ç°äº†æ–°çš„ AST èŠ‚ç‚¹ğŸ‰ã€‚

é€šè¿‡è¿™ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘ä»¬èƒ½å¤§æ¦‚ç†è§£ babel æ˜¯æ€ä¹ˆåŸºäº acorn å®ç° typescriptã€jsxã€flow è¯­æ³•è§£æçš„äº†ã€‚

ğŸŒ°æ¯”å¦‚ Literal æ‰©å±•äº† StringLiteralã€NumericLiteral ç­‰è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°±å¯ä»¥è‡ªå·±å®ç°ï¼š

```js
parseLiteral(...args) {
  const node = super.parseLiteral(...args)
  switch (typeof node.value) {
    case 'number':
      node.type = 'NumericLiteral'
      break
    case 'string':
      node.type = 'StringLiteral'
      break
  }
  return node
}
```



## æ€»ç»“

è¿™ä¸€èŠ‚æˆ‘ä»¬äº†è§£äº† js parser çš„å†å²ï¼Œä» SpiderMonkey çš„ AST æ ‡å‡†å¼€å§‹ï¼Œæ‰©å±•åˆ° espree çš„æ ‡å‡†ï¼Œæœ€æ—©çš„ estree æ ‡å‡†çš„å®ç°æ˜¯ esprimaï¼Œä½†æ˜¯éšç€ es2015 å¼€å§‹ä¸€å¹´ä¸€ä¸ªç‰ˆæœ¬ï¼Œesprima çš„è¿­ä»£é€Ÿåº¦é€æ¸è·Ÿä¸ä¸Šäº†ï¼Œè¿™æ—¶å€™ `acorn` æµè¡Œèµ·æ¥ï¼Œå› ä¸ºé€Ÿåº¦æ›´å¿«ï¼Œè€Œä¸”æ”¯æŒæ’ä»¶æ‰©å±•ï¼Œäºæ˜¯ espreeã€babel parser(babylon) ç­‰éƒ½åŸºäº acorn æ¥å®ç°å„è‡ªçš„ parserã€‚è™½ç„¶ estree ç³»åˆ—çš„ js parser æŒºå¤šçš„ï¼Œä½†ä¹Ÿä¸æ˜¯å…¨éƒ¨ï¼Œterserã€typescript ç­‰éƒ½æ˜¯ç”¨è‡ªå·±çš„ASTã€‚

å­¦å®Œè¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬æ›´å…¨é¢çš„äº†è§£äº† js parser çš„å†å²ï¼Œå¯¹å„ç§å·¥å…·æ‰€ç”¨çš„ parser ä¹‹é—´çš„å…³ç³»æœ‰äº†ä¸€å®šçš„äº†è§£ï¼Œå¹¶ä¸”è¿˜çŸ¥é“äº† acorn çš„è¯­æ³•æ’ä»¶è¯¥æ€ä¹ˆå†™ã€‚

æºç åœ°å€ï¼š

- [babel-plugin-exercise - @github](https://github.com/QuarkGluonPlasma/babel-plugin-exercize) å»ºè®® git clone ä¸‹æ¥é€šè¿‡ node è·‘ä¸€ä¸‹



2023å¹´04æœˆ06æ—¥11:18:23

